// Generated by gencpp from file behavior/TrackerCMD.msg
// DO NOT EDIT!


#ifndef BEHAVIOR_MESSAGE_TRACKERCMD_H
#define BEHAVIOR_MESSAGE_TRACKERCMD_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace behavior
{
template <class ContainerAllocator>
struct TrackerCMD_
{
  typedef TrackerCMD_<ContainerAllocator> Type;

  TrackerCMD_()
    : DesiredCurvature(0.0)
    , DesiredVelocity(0.0)
    , VehicleCommand(0)
    , YError(0.0)
    , HeadingError(0.0)
    , ControlMode(0)
    , SteerEnable(0)
    , BrakeFuelEnable(0)
    , left_light(0)
    , right_light(0)
    , horn(0)  {
    }
  TrackerCMD_(const ContainerAllocator& _alloc)
    : DesiredCurvature(0.0)
    , DesiredVelocity(0.0)
    , VehicleCommand(0)
    , YError(0.0)
    , HeadingError(0.0)
    , ControlMode(0)
    , SteerEnable(0)
    , BrakeFuelEnable(0)
    , left_light(0)
    , right_light(0)
    , horn(0)  {
  (void)_alloc;
    }



   typedef double _DesiredCurvature_type;
  _DesiredCurvature_type DesiredCurvature;

   typedef double _DesiredVelocity_type;
  _DesiredVelocity_type DesiredVelocity;

   typedef int32_t _VehicleCommand_type;
  _VehicleCommand_type VehicleCommand;

   typedef double _YError_type;
  _YError_type YError;

   typedef double _HeadingError_type;
  _HeadingError_type HeadingError;

   typedef int32_t _ControlMode_type;
  _ControlMode_type ControlMode;

   typedef int32_t _SteerEnable_type;
  _SteerEnable_type SteerEnable;

   typedef int32_t _BrakeFuelEnable_type;
  _BrakeFuelEnable_type BrakeFuelEnable;

   typedef int32_t _left_light_type;
  _left_light_type left_light;

   typedef int32_t _right_light_type;
  _right_light_type right_light;

   typedef int32_t _horn_type;
  _horn_type horn;





  typedef boost::shared_ptr< ::behavior::TrackerCMD_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::behavior::TrackerCMD_<ContainerAllocator> const> ConstPtr;

}; // struct TrackerCMD_

typedef ::behavior::TrackerCMD_<std::allocator<void> > TrackerCMD;

typedef boost::shared_ptr< ::behavior::TrackerCMD > TrackerCMDPtr;
typedef boost::shared_ptr< ::behavior::TrackerCMD const> TrackerCMDConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::behavior::TrackerCMD_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::behavior::TrackerCMD_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::behavior::TrackerCMD_<ContainerAllocator1> & lhs, const ::behavior::TrackerCMD_<ContainerAllocator2> & rhs)
{
  return lhs.DesiredCurvature == rhs.DesiredCurvature &&
    lhs.DesiredVelocity == rhs.DesiredVelocity &&
    lhs.VehicleCommand == rhs.VehicleCommand &&
    lhs.YError == rhs.YError &&
    lhs.HeadingError == rhs.HeadingError &&
    lhs.ControlMode == rhs.ControlMode &&
    lhs.SteerEnable == rhs.SteerEnable &&
    lhs.BrakeFuelEnable == rhs.BrakeFuelEnable &&
    lhs.left_light == rhs.left_light &&
    lhs.right_light == rhs.right_light &&
    lhs.horn == rhs.horn;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::behavior::TrackerCMD_<ContainerAllocator1> & lhs, const ::behavior::TrackerCMD_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace behavior

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::behavior::TrackerCMD_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::behavior::TrackerCMD_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behavior::TrackerCMD_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::behavior::TrackerCMD_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behavior::TrackerCMD_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::behavior::TrackerCMD_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::behavior::TrackerCMD_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b98e86766dfa6021d794ff4f3d9dc32a";
  }

  static const char* value(const ::behavior::TrackerCMD_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb98e86766dfa6021ULL;
  static const uint64_t static_value2 = 0xd794ff4f3d9dc32aULL;
};

template<class ContainerAllocator>
struct DataType< ::behavior::TrackerCMD_<ContainerAllocator> >
{
  static const char* value()
  {
    return "behavior/TrackerCMD";
  }

  static const char* value(const ::behavior::TrackerCMD_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::behavior::TrackerCMD_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 DesiredCurvature #期望曲率 1/m\n"
"float64 DesiredVelocity #期望速度 m/s\n"
"int32 VehicleCommand #//200～ES:紧急停车；201～ST：停车；AD_SPEED:前进速度跟踪；AD_DISTANCE:前进定距跟踪；AD_POINT:前进定点停车；BK_SPEED:后退速度跟踪；BK_DISTANCE:后退dingju跟踪；IG：点火；FO：熄火。\n"
"float64 YError #y方向误差 meter\n"
"float64 HeadingError #和期望路径点的角度误差 rad\n"
"int32 ControlMode #遥控模式REMOTECONTROLMODE=1001, 自主模式AUTOCONTROLMODE=1002, 未知模式UNKNOWNCONTROLMODE=1003\n"
"int32 SteerEnable #横向使能标0～无效  1～有效\n"
"int32 BrakeFuelEnable #纵向使能标0～无效 1～有效\n"
"int32 left_light #左转向灯0～灭 1～开\n"
"int32 right_light #右转向灯0～灭 1～开\n"
"int32 horn #喇叭0～关  1～开\n"
"\n"
"\n"
;
  }

  static const char* value(const ::behavior::TrackerCMD_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::behavior::TrackerCMD_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.DesiredCurvature);
      stream.next(m.DesiredVelocity);
      stream.next(m.VehicleCommand);
      stream.next(m.YError);
      stream.next(m.HeadingError);
      stream.next(m.ControlMode);
      stream.next(m.SteerEnable);
      stream.next(m.BrakeFuelEnable);
      stream.next(m.left_light);
      stream.next(m.right_light);
      stream.next(m.horn);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TrackerCMD_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::behavior::TrackerCMD_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::behavior::TrackerCMD_<ContainerAllocator>& v)
  {
    s << indent << "DesiredCurvature: ";
    Printer<double>::stream(s, indent + "  ", v.DesiredCurvature);
    s << indent << "DesiredVelocity: ";
    Printer<double>::stream(s, indent + "  ", v.DesiredVelocity);
    s << indent << "VehicleCommand: ";
    Printer<int32_t>::stream(s, indent + "  ", v.VehicleCommand);
    s << indent << "YError: ";
    Printer<double>::stream(s, indent + "  ", v.YError);
    s << indent << "HeadingError: ";
    Printer<double>::stream(s, indent + "  ", v.HeadingError);
    s << indent << "ControlMode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ControlMode);
    s << indent << "SteerEnable: ";
    Printer<int32_t>::stream(s, indent + "  ", v.SteerEnable);
    s << indent << "BrakeFuelEnable: ";
    Printer<int32_t>::stream(s, indent + "  ", v.BrakeFuelEnable);
    s << indent << "left_light: ";
    Printer<int32_t>::stream(s, indent + "  ", v.left_light);
    s << indent << "right_light: ";
    Printer<int32_t>::stream(s, indent + "  ", v.right_light);
    s << indent << "horn: ";
    Printer<int32_t>::stream(s, indent + "  ", v.horn);
  }
};

} // namespace message_operations
} // namespace ros

#endif // BEHAVIOR_MESSAGE_TRACKERCMD_H
