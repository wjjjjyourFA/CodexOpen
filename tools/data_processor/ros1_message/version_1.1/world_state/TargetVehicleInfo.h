// Generated by gencpp from file world_state/TargetVehicleInfo.msg
// DO NOT EDIT!


#ifndef WORLD_STATE_MESSAGE_TARGETVEHICLEINFO_H
#define WORLD_STATE_MESSAGE_TARGETVEHICLEINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace world_state
{
template <class ContainerAllocator>
struct TargetVehicleInfo_
{
  typedef TargetVehicleInfo_<ContainerAllocator> Type;

  TargetVehicleInfo_()
    : accX(0.0)
    , accY(0.0)
    , gyroZ(0.0)
    , actCurvature(0.0)
    , velocity(0.0)
    , lx(0.0)
    , ly(0.0)
    , lHd(0.0)
    , gx(0.0)
    , gy(0.0)
    , gHd(0.0)
    , gpsTime(0.0)
    , actGear(0)
    , isUpdate(0)  {
    }
  TargetVehicleInfo_(const ContainerAllocator& _alloc)
    : accX(0.0)
    , accY(0.0)
    , gyroZ(0.0)
    , actCurvature(0.0)
    , velocity(0.0)
    , lx(0.0)
    , ly(0.0)
    , lHd(0.0)
    , gx(0.0)
    , gy(0.0)
    , gHd(0.0)
    , gpsTime(0.0)
    , actGear(0)
    , isUpdate(0)  {
  (void)_alloc;
    }



   typedef double _accX_type;
  _accX_type accX;

   typedef double _accY_type;
  _accY_type accY;

   typedef double _gyroZ_type;
  _gyroZ_type gyroZ;

   typedef double _actCurvature_type;
  _actCurvature_type actCurvature;

   typedef double _velocity_type;
  _velocity_type velocity;

   typedef double _lx_type;
  _lx_type lx;

   typedef double _ly_type;
  _ly_type ly;

   typedef double _lHd_type;
  _lHd_type lHd;

   typedef double _gx_type;
  _gx_type gx;

   typedef double _gy_type;
  _gy_type gy;

   typedef double _gHd_type;
  _gHd_type gHd;

   typedef double _gpsTime_type;
  _gpsTime_type gpsTime;

   typedef uint8_t _actGear_type;
  _actGear_type actGear;

   typedef int8_t _isUpdate_type;
  _isUpdate_type isUpdate;





  typedef boost::shared_ptr< ::world_state::TargetVehicleInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::world_state::TargetVehicleInfo_<ContainerAllocator> const> ConstPtr;

}; // struct TargetVehicleInfo_

typedef ::world_state::TargetVehicleInfo_<std::allocator<void> > TargetVehicleInfo;

typedef boost::shared_ptr< ::world_state::TargetVehicleInfo > TargetVehicleInfoPtr;
typedef boost::shared_ptr< ::world_state::TargetVehicleInfo const> TargetVehicleInfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::world_state::TargetVehicleInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::world_state::TargetVehicleInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::world_state::TargetVehicleInfo_<ContainerAllocator1> & lhs, const ::world_state::TargetVehicleInfo_<ContainerAllocator2> & rhs)
{
  return lhs.accX == rhs.accX &&
    lhs.accY == rhs.accY &&
    lhs.gyroZ == rhs.gyroZ &&
    lhs.actCurvature == rhs.actCurvature &&
    lhs.velocity == rhs.velocity &&
    lhs.lx == rhs.lx &&
    lhs.ly == rhs.ly &&
    lhs.lHd == rhs.lHd &&
    lhs.gx == rhs.gx &&
    lhs.gy == rhs.gy &&
    lhs.gHd == rhs.gHd &&
    lhs.gpsTime == rhs.gpsTime &&
    lhs.actGear == rhs.actGear &&
    lhs.isUpdate == rhs.isUpdate;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::world_state::TargetVehicleInfo_<ContainerAllocator1> & lhs, const ::world_state::TargetVehicleInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace world_state

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::world_state::TargetVehicleInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::world_state::TargetVehicleInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::world_state::TargetVehicleInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "792b40161ef6b405f593b6c0036b6503";
  }

  static const char* value(const ::world_state::TargetVehicleInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x792b40161ef6b405ULL;
  static const uint64_t static_value2 = 0xf593b6c0036b6503ULL;
};

template<class ContainerAllocator>
struct DataType< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "world_state/TargetVehicleInfo";
  }

  static const char* value(const ::world_state::TargetVehicleInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 accX ##m^2/s\n"
"float64 accY\n"
"float64 gyroZ##前车角速度\n"
"float64 actCurvature##前车当前曲率1/m\n"
"float64 velocity##前车速度m/s\n"
"float64 lx ##目标车辆递推局部坐标X 米\n"
"float64 ly\n"
"float64 lHd##rad 弧度\n"
"float64 gx##全局GPS高斯坐标X米\n"
"float64 gy\n"
"float64 gHd##弧度\n"
"float64 gpsTime##ms\n"
"uint8 actGear##前车实际档位\n"
"int8 isUpdate##0~消息没刷新 1～消息刷新\n"
;
  }

  static const char* value(const ::world_state::TargetVehicleInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.accX);
      stream.next(m.accY);
      stream.next(m.gyroZ);
      stream.next(m.actCurvature);
      stream.next(m.velocity);
      stream.next(m.lx);
      stream.next(m.ly);
      stream.next(m.lHd);
      stream.next(m.gx);
      stream.next(m.gy);
      stream.next(m.gHd);
      stream.next(m.gpsTime);
      stream.next(m.actGear);
      stream.next(m.isUpdate);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct TargetVehicleInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::world_state::TargetVehicleInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::world_state::TargetVehicleInfo_<ContainerAllocator>& v)
  {
    s << indent << "accX: ";
    Printer<double>::stream(s, indent + "  ", v.accX);
    s << indent << "accY: ";
    Printer<double>::stream(s, indent + "  ", v.accY);
    s << indent << "gyroZ: ";
    Printer<double>::stream(s, indent + "  ", v.gyroZ);
    s << indent << "actCurvature: ";
    Printer<double>::stream(s, indent + "  ", v.actCurvature);
    s << indent << "velocity: ";
    Printer<double>::stream(s, indent + "  ", v.velocity);
    s << indent << "lx: ";
    Printer<double>::stream(s, indent + "  ", v.lx);
    s << indent << "ly: ";
    Printer<double>::stream(s, indent + "  ", v.ly);
    s << indent << "lHd: ";
    Printer<double>::stream(s, indent + "  ", v.lHd);
    s << indent << "gx: ";
    Printer<double>::stream(s, indent + "  ", v.gx);
    s << indent << "gy: ";
    Printer<double>::stream(s, indent + "  ", v.gy);
    s << indent << "gHd: ";
    Printer<double>::stream(s, indent + "  ", v.gHd);
    s << indent << "gpsTime: ";
    Printer<double>::stream(s, indent + "  ", v.gpsTime);
    s << indent << "actGear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.actGear);
    s << indent << "isUpdate: ";
    Printer<int8_t>::stream(s, indent + "  ", v.isUpdate);
  }
};

} // namespace message_operations
} // namespace ros

#endif // WORLD_STATE_MESSAGE_TARGETVEHICLEINFO_H
