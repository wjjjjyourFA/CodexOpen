// Generated by gencpp from file self_state/ChassisInfo.msg
// DO NOT EDIT!


#ifndef SELF_STATE_MESSAGE_CHASSISINFO_H
#define SELF_STATE_MESSAGE_CHASSISINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace self_state
{
template <class ContainerAllocator>
struct ChassisInfo_
{
  typedef ChassisInfo_<ContainerAllocator> Type;

  ChassisInfo_()
    : local_time(0.0)
    , UTC_time(0.0)
    , message_num(0)
    , lf_wheel_speed(0.0)
    , lr_wheel_speed(0.0)
    , rf_wheel_speed(0.0)
    , rr_wheel_speed(0.0)
    , lf_wheel_pulse_counter(0)
    , lr_wheel_pulse_counter(0)
    , rf_wheel_pulse_counter(0)
    , rr_wheel_pulse_counter(0)
    , lon_acc(0.0)
    , lat_acc(0.0)
    , yaw_rate(0.0)
    , cur_spd(0.0)
    , exp_speed(0.0)
    , exp_acceleration(0.0)
    , exp_yaw_rate(0.0)
    , exp_steer_wheel_angle(0.0)
    , exp_steer_wheel_speed(0.0)
    , exp_fuel(0.0)
    , exp_brake(0.0)
    , exp_gear(0)
    , exp_handbrake(0)
    , cur_steer_wheel_angle(0.0)
    , cur_steer_wheel_speed(0.0)
    , cur_fuel(0.0)
    , cur_brake(0.0)
    , cur_engine_speed(0.0)
    , cur_gear(0)
    , cur_handbrake(0)
    , actual_gear(0)
    , exp_AutoEnable(0)
    , AutoEnable(0)
    , oil(0)
    , battery_SOC(0)
    , sta_code(0)
    , err_code(0)
    , horn(0)
    , left_signal_light(0)
    , right_signal_light(0)
    , headlight(0)
    , brake_light(0)
    , postion_light(0)
    , high_beam(0)
    , low_beam(0)
    , front_fog_light(0)
    , rear_fog_light(0)
    , StateAct(0)
    , ElectricalPowerSteeringAvailablityStatus(0)
    , VehSpdValidFlag(0)
    , reserved()  {
      reserved.assign(0);
  }
  ChassisInfo_(const ContainerAllocator& _alloc)
    : local_time(0.0)
    , UTC_time(0.0)
    , message_num(0)
    , lf_wheel_speed(0.0)
    , lr_wheel_speed(0.0)
    , rf_wheel_speed(0.0)
    , rr_wheel_speed(0.0)
    , lf_wheel_pulse_counter(0)
    , lr_wheel_pulse_counter(0)
    , rf_wheel_pulse_counter(0)
    , rr_wheel_pulse_counter(0)
    , lon_acc(0.0)
    , lat_acc(0.0)
    , yaw_rate(0.0)
    , cur_spd(0.0)
    , exp_speed(0.0)
    , exp_acceleration(0.0)
    , exp_yaw_rate(0.0)
    , exp_steer_wheel_angle(0.0)
    , exp_steer_wheel_speed(0.0)
    , exp_fuel(0.0)
    , exp_brake(0.0)
    , exp_gear(0)
    , exp_handbrake(0)
    , cur_steer_wheel_angle(0.0)
    , cur_steer_wheel_speed(0.0)
    , cur_fuel(0.0)
    , cur_brake(0.0)
    , cur_engine_speed(0.0)
    , cur_gear(0)
    , cur_handbrake(0)
    , actual_gear(0)
    , exp_AutoEnable(0)
    , AutoEnable(0)
    , oil(0)
    , battery_SOC(0)
    , sta_code(0)
    , err_code(0)
    , horn(0)
    , left_signal_light(0)
    , right_signal_light(0)
    , headlight(0)
    , brake_light(0)
    , postion_light(0)
    , high_beam(0)
    , low_beam(0)
    , front_fog_light(0)
    , rear_fog_light(0)
    , StateAct(0)
    , ElectricalPowerSteeringAvailablityStatus(0)
    , VehSpdValidFlag(0)
    , reserved()  {
  (void)_alloc;
      reserved.assign(0);
  }



   typedef double _local_time_type;
  _local_time_type local_time;

   typedef double _UTC_time_type;
  _UTC_time_type UTC_time;

   typedef int32_t _message_num_type;
  _message_num_type message_num;

   typedef double _lf_wheel_speed_type;
  _lf_wheel_speed_type lf_wheel_speed;

   typedef double _lr_wheel_speed_type;
  _lr_wheel_speed_type lr_wheel_speed;

   typedef double _rf_wheel_speed_type;
  _rf_wheel_speed_type rf_wheel_speed;

   typedef double _rr_wheel_speed_type;
  _rr_wheel_speed_type rr_wheel_speed;

   typedef uint64_t _lf_wheel_pulse_counter_type;
  _lf_wheel_pulse_counter_type lf_wheel_pulse_counter;

   typedef uint64_t _lr_wheel_pulse_counter_type;
  _lr_wheel_pulse_counter_type lr_wheel_pulse_counter;

   typedef uint64_t _rf_wheel_pulse_counter_type;
  _rf_wheel_pulse_counter_type rf_wheel_pulse_counter;

   typedef uint64_t _rr_wheel_pulse_counter_type;
  _rr_wheel_pulse_counter_type rr_wheel_pulse_counter;

   typedef double _lon_acc_type;
  _lon_acc_type lon_acc;

   typedef double _lat_acc_type;
  _lat_acc_type lat_acc;

   typedef double _yaw_rate_type;
  _yaw_rate_type yaw_rate;

   typedef double _cur_spd_type;
  _cur_spd_type cur_spd;

   typedef double _exp_speed_type;
  _exp_speed_type exp_speed;

   typedef double _exp_acceleration_type;
  _exp_acceleration_type exp_acceleration;

   typedef double _exp_yaw_rate_type;
  _exp_yaw_rate_type exp_yaw_rate;

   typedef double _exp_steer_wheel_angle_type;
  _exp_steer_wheel_angle_type exp_steer_wheel_angle;

   typedef double _exp_steer_wheel_speed_type;
  _exp_steer_wheel_speed_type exp_steer_wheel_speed;

   typedef double _exp_fuel_type;
  _exp_fuel_type exp_fuel;

   typedef double _exp_brake_type;
  _exp_brake_type exp_brake;

   typedef int8_t _exp_gear_type;
  _exp_gear_type exp_gear;

   typedef int8_t _exp_handbrake_type;
  _exp_handbrake_type exp_handbrake;

   typedef double _cur_steer_wheel_angle_type;
  _cur_steer_wheel_angle_type cur_steer_wheel_angle;

   typedef double _cur_steer_wheel_speed_type;
  _cur_steer_wheel_speed_type cur_steer_wheel_speed;

   typedef double _cur_fuel_type;
  _cur_fuel_type cur_fuel;

   typedef double _cur_brake_type;
  _cur_brake_type cur_brake;

   typedef double _cur_engine_speed_type;
  _cur_engine_speed_type cur_engine_speed;

   typedef uint8_t _cur_gear_type;
  _cur_gear_type cur_gear;

   typedef uint8_t _cur_handbrake_type;
  _cur_handbrake_type cur_handbrake;

   typedef uint8_t _actual_gear_type;
  _actual_gear_type actual_gear;

   typedef int8_t _exp_AutoEnable_type;
  _exp_AutoEnable_type exp_AutoEnable;

   typedef int8_t _AutoEnable_type;
  _AutoEnable_type AutoEnable;

   typedef int8_t _oil_type;
  _oil_type oil;

   typedef int8_t _battery_SOC_type;
  _battery_SOC_type battery_SOC;

   typedef uint32_t _sta_code_type;
  _sta_code_type sta_code;

   typedef uint32_t _err_code_type;
  _err_code_type err_code;

   typedef uint8_t _horn_type;
  _horn_type horn;

   typedef uint8_t _left_signal_light_type;
  _left_signal_light_type left_signal_light;

   typedef uint8_t _right_signal_light_type;
  _right_signal_light_type right_signal_light;

   typedef uint8_t _headlight_type;
  _headlight_type headlight;

   typedef uint8_t _brake_light_type;
  _brake_light_type brake_light;

   typedef uint8_t _postion_light_type;
  _postion_light_type postion_light;

   typedef uint8_t _high_beam_type;
  _high_beam_type high_beam;

   typedef uint8_t _low_beam_type;
  _low_beam_type low_beam;

   typedef uint8_t _front_fog_light_type;
  _front_fog_light_type front_fog_light;

   typedef uint8_t _rear_fog_light_type;
  _rear_fog_light_type rear_fog_light;

   typedef uint8_t _StateAct_type;
  _StateAct_type StateAct;

   typedef uint8_t _ElectricalPowerSteeringAvailablityStatus_type;
  _ElectricalPowerSteeringAvailablityStatus_type ElectricalPowerSteeringAvailablityStatus;

   typedef uint8_t _VehSpdValidFlag_type;
  _VehSpdValidFlag_type VehSpdValidFlag;

   typedef boost::array<uint32_t, 8>  _reserved_type;
  _reserved_type reserved;





  typedef boost::shared_ptr< ::self_state::ChassisInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::self_state::ChassisInfo_<ContainerAllocator> const> ConstPtr;

}; // struct ChassisInfo_

typedef ::self_state::ChassisInfo_<std::allocator<void> > ChassisInfo;

typedef boost::shared_ptr< ::self_state::ChassisInfo > ChassisInfoPtr;
typedef boost::shared_ptr< ::self_state::ChassisInfo const> ChassisInfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::self_state::ChassisInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::self_state::ChassisInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::self_state::ChassisInfo_<ContainerAllocator1> & lhs, const ::self_state::ChassisInfo_<ContainerAllocator2> & rhs)
{
  return lhs.local_time == rhs.local_time &&
    lhs.UTC_time == rhs.UTC_time &&
    lhs.message_num == rhs.message_num &&
    lhs.lf_wheel_speed == rhs.lf_wheel_speed &&
    lhs.lr_wheel_speed == rhs.lr_wheel_speed &&
    lhs.rf_wheel_speed == rhs.rf_wheel_speed &&
    lhs.rr_wheel_speed == rhs.rr_wheel_speed &&
    lhs.lf_wheel_pulse_counter == rhs.lf_wheel_pulse_counter &&
    lhs.lr_wheel_pulse_counter == rhs.lr_wheel_pulse_counter &&
    lhs.rf_wheel_pulse_counter == rhs.rf_wheel_pulse_counter &&
    lhs.rr_wheel_pulse_counter == rhs.rr_wheel_pulse_counter &&
    lhs.lon_acc == rhs.lon_acc &&
    lhs.lat_acc == rhs.lat_acc &&
    lhs.yaw_rate == rhs.yaw_rate &&
    lhs.cur_spd == rhs.cur_spd &&
    lhs.exp_speed == rhs.exp_speed &&
    lhs.exp_acceleration == rhs.exp_acceleration &&
    lhs.exp_yaw_rate == rhs.exp_yaw_rate &&
    lhs.exp_steer_wheel_angle == rhs.exp_steer_wheel_angle &&
    lhs.exp_steer_wheel_speed == rhs.exp_steer_wheel_speed &&
    lhs.exp_fuel == rhs.exp_fuel &&
    lhs.exp_brake == rhs.exp_brake &&
    lhs.exp_gear == rhs.exp_gear &&
    lhs.exp_handbrake == rhs.exp_handbrake &&
    lhs.cur_steer_wheel_angle == rhs.cur_steer_wheel_angle &&
    lhs.cur_steer_wheel_speed == rhs.cur_steer_wheel_speed &&
    lhs.cur_fuel == rhs.cur_fuel &&
    lhs.cur_brake == rhs.cur_brake &&
    lhs.cur_engine_speed == rhs.cur_engine_speed &&
    lhs.cur_gear == rhs.cur_gear &&
    lhs.cur_handbrake == rhs.cur_handbrake &&
    lhs.actual_gear == rhs.actual_gear &&
    lhs.exp_AutoEnable == rhs.exp_AutoEnable &&
    lhs.AutoEnable == rhs.AutoEnable &&
    lhs.oil == rhs.oil &&
    lhs.battery_SOC == rhs.battery_SOC &&
    lhs.sta_code == rhs.sta_code &&
    lhs.err_code == rhs.err_code &&
    lhs.horn == rhs.horn &&
    lhs.left_signal_light == rhs.left_signal_light &&
    lhs.right_signal_light == rhs.right_signal_light &&
    lhs.headlight == rhs.headlight &&
    lhs.brake_light == rhs.brake_light &&
    lhs.postion_light == rhs.postion_light &&
    lhs.high_beam == rhs.high_beam &&
    lhs.low_beam == rhs.low_beam &&
    lhs.front_fog_light == rhs.front_fog_light &&
    lhs.rear_fog_light == rhs.rear_fog_light &&
    lhs.StateAct == rhs.StateAct &&
    lhs.ElectricalPowerSteeringAvailablityStatus == rhs.ElectricalPowerSteeringAvailablityStatus &&
    lhs.VehSpdValidFlag == rhs.VehSpdValidFlag &&
    lhs.reserved == rhs.reserved;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::self_state::ChassisInfo_<ContainerAllocator1> & lhs, const ::self_state::ChassisInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace self_state

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::self_state::ChassisInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::self_state::ChassisInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::self_state::ChassisInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::self_state::ChassisInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::self_state::ChassisInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::self_state::ChassisInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::self_state::ChassisInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "966ce8955e3ee349ae78973711c0f38b";
  }

  static const char* value(const ::self_state::ChassisInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x966ce8955e3ee349ULL;
  static const uint64_t static_value2 = 0xae78973711c0f38bULL;
};

template<class ContainerAllocator>
struct DataType< ::self_state::ChassisInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "self_state/ChassisInfo";
  }

  static const char* value(const ::self_state::ChassisInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::self_state::ChassisInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 local_time		# in ms\n"
"float64 UTC_time		# in ms\n"
"int32   message_num	\n"
"\n"
"float64 lf_wheel_speed	        # wheel speed of the left front wheel m/s\n"
"float64 lr_wheel_speed	        # wheel speed of the left rear wheel m/s\n"
"float64 rf_wheel_speed	        # wheel speed of the right front wheel m/s\n"
"float64 rr_wheel_speed	        # wheel speed of the right rear wheel m/s\n"
"\n"
"uint64 lf_wheel_pulse_counter	# pulse count of the left front wheel\n"
"uint64 lr_wheel_pulse_counter  	# pulse count of the left rear wheel\n"
"uint64 rf_wheel_pulse_counter	# pulse count of the right front wheel\n"
"uint64 rr_wheel_pulse_counter	# pulse count of the right rear wheel\n"
"\n"
"float64 lon_acc 		# longitudinal acceration, m/s2\n"
"float64 lat_acc		# later acceleration, m/s2\n"
"float64 yaw_rate		# yaw rate, degree/s\n"
"float64 cur_spd		# current speed,m/s\n"
"\n"
"float64  exp_speed             # m/s       >0: foward, m/s, <0: backward\n"
"float64  exp_acceleration      # m/s^2     >0: accelerate,  <0: decelerate\n"
"float64  exp_yaw_rate          # degree/s  >0: counter-clockwise\n"
"\n"
"float64 exp_steer_wheel_angle	# expected steer wheel angle,unit:degree\n"
"float64 exp_steer_wheel_speed 	# expected steer wheel speed,unit:degree/s\n"
"float64 exp_fuel		# expected fuel value, 0~1\n"
"float64 exp_brake		# expected brake value, 0~1\n"
"int8 exp_gear		# expected gear position, 1:N  2:D 3:R 4: P\n"
"int8 exp_handbrake	# expected handbrake status, 0:off 2:on \n"
"\n"
"float64 cur_steer_wheel_angle  # current steering wheel angle, unit:degree\n"
"float64 cur_steer_wheel_speed 	# current steer wheel speed,unit:degree/s\n"
"float64 cur_fuel		# curren fuel value, 0~1\n"
"float64 cur_brake		# current brake value, 0~1\n"
"float64 cur_engine_speed	# current engine speed \n"
"uint8 cur_gear		# current gear position, 1:N  2:D 3:R 4: P\n"
"uint8 cur_handbrake	# current handbrake status, 0:off 2:on\n"
"uint8 actual_gear	#localpose use tcu1.actualGear p~5 r~6 n~0 d~1\n"
"int8 exp_AutoEnable	        #  0: off  1: on \n"
"int8 AutoEnable	        #  0: off  1: on \n"
"\n"
"int8 oil                	# oil quantity 0~100%\n"
"int8 battery_SOC               # battery quantity 0~100% \n"
"\n"
"uint32  sta_code 		# status code of the low-level controller\n"
"uint32  err_code 		# error code of the low-level controller\n"
"uint8   horn    		# horn: 0-OFF, 1-ON, 2-BLINK\n"
"\n"
"uint8   left_signal_light    	# left-turn light: 0-OFF, 1-ON, 2-BLINK\n"
"uint8   right_signal_light      # right-turn light: 0-OFF, 1-ON, 2-BLINK\n"
"uint8   headlight    		# front light: 0-OFF, 1-ON, 2-BLINK\n"
"\n"
"uint8   brake_light		# break light: 0-OFF, 1-ON, 2-BLINK \n"
"uint8   postion_light		# postion light: 0-OFF, 1-ON, 2-BLINK \n"
"uint8   high_beam		# high neam: 0-OFF, 1-ON, 2-BLINK \n"
"uint8   low_beam		# high neam: 0-OFF, 1-ON, 2-BLINK \n"
"uint8   front_fog_light		# front_fog_light: 0-OFF, 1-ON, 2-BLINK \n"
"uint8   rear_fog_light		# front_fog_light: 0-OFF, 1-ON, 2-BLINK \n"
"uint8   StateAct            	# 制动系统工作状态反馈\n"
"uint8 ElectricalPowerSteeringAvailablityStatus \n"
"uint8 VehSpdValidFlag \n"
"uint32[8] reserved\n"
"\n"
"\n"
"\n"
"\n"
"\n"
;
  }

  static const char* value(const ::self_state::ChassisInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::self_state::ChassisInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.local_time);
      stream.next(m.UTC_time);
      stream.next(m.message_num);
      stream.next(m.lf_wheel_speed);
      stream.next(m.lr_wheel_speed);
      stream.next(m.rf_wheel_speed);
      stream.next(m.rr_wheel_speed);
      stream.next(m.lf_wheel_pulse_counter);
      stream.next(m.lr_wheel_pulse_counter);
      stream.next(m.rf_wheel_pulse_counter);
      stream.next(m.rr_wheel_pulse_counter);
      stream.next(m.lon_acc);
      stream.next(m.lat_acc);
      stream.next(m.yaw_rate);
      stream.next(m.cur_spd);
      stream.next(m.exp_speed);
      stream.next(m.exp_acceleration);
      stream.next(m.exp_yaw_rate);
      stream.next(m.exp_steer_wheel_angle);
      stream.next(m.exp_steer_wheel_speed);
      stream.next(m.exp_fuel);
      stream.next(m.exp_brake);
      stream.next(m.exp_gear);
      stream.next(m.exp_handbrake);
      stream.next(m.cur_steer_wheel_angle);
      stream.next(m.cur_steer_wheel_speed);
      stream.next(m.cur_fuel);
      stream.next(m.cur_brake);
      stream.next(m.cur_engine_speed);
      stream.next(m.cur_gear);
      stream.next(m.cur_handbrake);
      stream.next(m.actual_gear);
      stream.next(m.exp_AutoEnable);
      stream.next(m.AutoEnable);
      stream.next(m.oil);
      stream.next(m.battery_SOC);
      stream.next(m.sta_code);
      stream.next(m.err_code);
      stream.next(m.horn);
      stream.next(m.left_signal_light);
      stream.next(m.right_signal_light);
      stream.next(m.headlight);
      stream.next(m.brake_light);
      stream.next(m.postion_light);
      stream.next(m.high_beam);
      stream.next(m.low_beam);
      stream.next(m.front_fog_light);
      stream.next(m.rear_fog_light);
      stream.next(m.StateAct);
      stream.next(m.ElectricalPowerSteeringAvailablityStatus);
      stream.next(m.VehSpdValidFlag);
      stream.next(m.reserved);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ChassisInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::self_state::ChassisInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::self_state::ChassisInfo_<ContainerAllocator>& v)
  {
    s << indent << "local_time: ";
    Printer<double>::stream(s, indent + "  ", v.local_time);
    s << indent << "UTC_time: ";
    Printer<double>::stream(s, indent + "  ", v.UTC_time);
    s << indent << "message_num: ";
    Printer<int32_t>::stream(s, indent + "  ", v.message_num);
    s << indent << "lf_wheel_speed: ";
    Printer<double>::stream(s, indent + "  ", v.lf_wheel_speed);
    s << indent << "lr_wheel_speed: ";
    Printer<double>::stream(s, indent + "  ", v.lr_wheel_speed);
    s << indent << "rf_wheel_speed: ";
    Printer<double>::stream(s, indent + "  ", v.rf_wheel_speed);
    s << indent << "rr_wheel_speed: ";
    Printer<double>::stream(s, indent + "  ", v.rr_wheel_speed);
    s << indent << "lf_wheel_pulse_counter: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.lf_wheel_pulse_counter);
    s << indent << "lr_wheel_pulse_counter: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.lr_wheel_pulse_counter);
    s << indent << "rf_wheel_pulse_counter: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.rf_wheel_pulse_counter);
    s << indent << "rr_wheel_pulse_counter: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.rr_wheel_pulse_counter);
    s << indent << "lon_acc: ";
    Printer<double>::stream(s, indent + "  ", v.lon_acc);
    s << indent << "lat_acc: ";
    Printer<double>::stream(s, indent + "  ", v.lat_acc);
    s << indent << "yaw_rate: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_rate);
    s << indent << "cur_spd: ";
    Printer<double>::stream(s, indent + "  ", v.cur_spd);
    s << indent << "exp_speed: ";
    Printer<double>::stream(s, indent + "  ", v.exp_speed);
    s << indent << "exp_acceleration: ";
    Printer<double>::stream(s, indent + "  ", v.exp_acceleration);
    s << indent << "exp_yaw_rate: ";
    Printer<double>::stream(s, indent + "  ", v.exp_yaw_rate);
    s << indent << "exp_steer_wheel_angle: ";
    Printer<double>::stream(s, indent + "  ", v.exp_steer_wheel_angle);
    s << indent << "exp_steer_wheel_speed: ";
    Printer<double>::stream(s, indent + "  ", v.exp_steer_wheel_speed);
    s << indent << "exp_fuel: ";
    Printer<double>::stream(s, indent + "  ", v.exp_fuel);
    s << indent << "exp_brake: ";
    Printer<double>::stream(s, indent + "  ", v.exp_brake);
    s << indent << "exp_gear: ";
    Printer<int8_t>::stream(s, indent + "  ", v.exp_gear);
    s << indent << "exp_handbrake: ";
    Printer<int8_t>::stream(s, indent + "  ", v.exp_handbrake);
    s << indent << "cur_steer_wheel_angle: ";
    Printer<double>::stream(s, indent + "  ", v.cur_steer_wheel_angle);
    s << indent << "cur_steer_wheel_speed: ";
    Printer<double>::stream(s, indent + "  ", v.cur_steer_wheel_speed);
    s << indent << "cur_fuel: ";
    Printer<double>::stream(s, indent + "  ", v.cur_fuel);
    s << indent << "cur_brake: ";
    Printer<double>::stream(s, indent + "  ", v.cur_brake);
    s << indent << "cur_engine_speed: ";
    Printer<double>::stream(s, indent + "  ", v.cur_engine_speed);
    s << indent << "cur_gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cur_gear);
    s << indent << "cur_handbrake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cur_handbrake);
    s << indent << "actual_gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.actual_gear);
    s << indent << "exp_AutoEnable: ";
    Printer<int8_t>::stream(s, indent + "  ", v.exp_AutoEnable);
    s << indent << "AutoEnable: ";
    Printer<int8_t>::stream(s, indent + "  ", v.AutoEnable);
    s << indent << "oil: ";
    Printer<int8_t>::stream(s, indent + "  ", v.oil);
    s << indent << "battery_SOC: ";
    Printer<int8_t>::stream(s, indent + "  ", v.battery_SOC);
    s << indent << "sta_code: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.sta_code);
    s << indent << "err_code: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.err_code);
    s << indent << "horn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.horn);
    s << indent << "left_signal_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.left_signal_light);
    s << indent << "right_signal_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.right_signal_light);
    s << indent << "headlight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.headlight);
    s << indent << "brake_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.brake_light);
    s << indent << "postion_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.postion_light);
    s << indent << "high_beam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.high_beam);
    s << indent << "low_beam: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.low_beam);
    s << indent << "front_fog_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.front_fog_light);
    s << indent << "rear_fog_light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rear_fog_light);
    s << indent << "StateAct: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StateAct);
    s << indent << "ElectricalPowerSteeringAvailablityStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ElectricalPowerSteeringAvailablityStatus);
    s << indent << "VehSpdValidFlag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.VehSpdValidFlag);
    s << indent << "reserved[]" << std::endl;
    for (size_t i = 0; i < v.reserved.size(); ++i)
    {
      s << indent << "  reserved[" << i << "]: ";
      Printer<uint32_t>::stream(s, indent + "  ", v.reserved[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // SELF_STATE_MESSAGE_CHASSISINFO_H
