// Generated by gencpp from file sensor/ESR_Radar_Info.msg
// DO NOT EDIT!


#ifndef SENSOR_MESSAGE_ESR_RADAR_INFO_H
#define SENSOR_MESSAGE_ESR_RADAR_INFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <geometry_msgs/Pose2D.h>
#include <sensor/ESR_Radar_Object.h>

namespace sensor
{
template <class ContainerAllocator>
struct ESR_Radar_Info_
{
  typedef ESR_Radar_Info_<ContainerAllocator> Type;

  ESR_Radar_Info_()
    : header()
    , local_time(0.0)
    , gps_time(0.0)
    , localposeStamped()
    , radarID(0)
    , objectNum(0)
    , objectData()  {
    }
  ESR_Radar_Info_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , local_time(0.0)
    , gps_time(0.0)
    , localposeStamped(_alloc)
    , radarID(0)
    , objectNum(0)
    , objectData(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _local_time_type;
  _local_time_type local_time;

   typedef double _gps_time_type;
  _gps_time_type gps_time;

   typedef  ::geometry_msgs::Pose2D_<ContainerAllocator>  _localposeStamped_type;
  _localposeStamped_type localposeStamped;

   typedef int32_t _radarID_type;
  _radarID_type radarID;

   typedef int32_t _objectNum_type;
  _objectNum_type objectNum;

   typedef std::vector< ::sensor::ESR_Radar_Object_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::sensor::ESR_Radar_Object_<ContainerAllocator> >> _objectData_type;
  _objectData_type objectData;





  typedef boost::shared_ptr< ::sensor::ESR_Radar_Info_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::sensor::ESR_Radar_Info_<ContainerAllocator> const> ConstPtr;

}; // struct ESR_Radar_Info_

typedef ::sensor::ESR_Radar_Info_<std::allocator<void> > ESR_Radar_Info;

typedef boost::shared_ptr< ::sensor::ESR_Radar_Info > ESR_Radar_InfoPtr;
typedef boost::shared_ptr< ::sensor::ESR_Radar_Info const> ESR_Radar_InfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::sensor::ESR_Radar_Info_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::sensor::ESR_Radar_Info_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::sensor::ESR_Radar_Info_<ContainerAllocator1> & lhs, const ::sensor::ESR_Radar_Info_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.local_time == rhs.local_time &&
    lhs.gps_time == rhs.gps_time &&
    lhs.localposeStamped == rhs.localposeStamped &&
    lhs.radarID == rhs.radarID &&
    lhs.objectNum == rhs.objectNum &&
    lhs.objectData == rhs.objectData;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::sensor::ESR_Radar_Info_<ContainerAllocator1> & lhs, const ::sensor::ESR_Radar_Info_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace sensor

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::sensor::ESR_Radar_Info_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::sensor::ESR_Radar_Info_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sensor::ESR_Radar_Info_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9b7c7151129af6faf034fd7bc1a15006";
  }

  static const char* value(const ::sensor::ESR_Radar_Info_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9b7c7151129af6faULL;
  static const uint64_t static_value2 = 0xf034fd7bc1a15006ULL;
};

template<class ContainerAllocator>
struct DataType< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
{
  static const char* value()
  {
    return "sensor/ESR_Radar_Info";
  }

  static const char* value(const ::sensor::ESR_Radar_Info_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header     header\n"
"float64 local_time		# in ms\n"
"float64 gps_time		# in ms\n"
"geometry_msgs/Pose2D localposeStamped \n"
"\n"
"int32               radarID         # Radar identification\n"
"int32               objectNum       # number of returned effective targets\n"
"ESR_Radar_Object[]     objectData      # the number of targets\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Pose2D\n"
"# Deprecated\n"
"# Please use the full 3D pose.\n"
"\n"
"# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.\n"
"\n"
"# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.\n"
"\n"
"\n"
"# This expresses a position and orientation on a 2D manifold.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 theta\n"
"\n"
"================================================================================\n"
"MSG: sensor/ESR_Radar_Object\n"
"int8       targetID         #雷达目标ID（1~64）\n"
"float64    range            #目标距离（m）\n"
"float64    angle            #角度（rad），正前为0，left为正\n"
"float64    front_distance   # position in front of the car （m)\n"
"float64    left_distance    # position in left of the car（m）\n"
"float64    Speed            # m/s  composition of speed\n"
"#float64    Speed_x          # m/s  localpose x_axis\n"
"#float64    Speed_y          # m/s  localpose y_axis\n"
"float64    height           #高度（暂无）\n"
"float64    width            #宽度（暂无）\n"
"float64    rangeRate        #距离变化率（m/s），远离为正，接近为负\n"
"float64    latRate          #角速度（rad/s），逆时针为正\n"
"int8       trackStatus      #目标追踪状态 ESR_NO_TARGET = 0, ESR_NEW_TARGET =1,ESR_UPDATED_TARGET=3,ESR_COASTED_TARGET=4,ESR_INVALID_COASTED_TARGET=6\n"
"int8       isACCTarget      # 0-no, 1-stat, 2-move\n"
"int8       isCMBBTarget     # 0-no, 1-stat, 2-move\n"
"int8       isFCWTarget      # 0-no, 1-stat, 2-move\n"
"int8 	   type	     #障碍物类型\n"
"int8	   confidence	    #待添加\n"
"int8       rcsvalue	    #待添加\n"
;
  }

  static const char* value(const ::sensor::ESR_Radar_Info_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.local_time);
      stream.next(m.gps_time);
      stream.next(m.localposeStamped);
      stream.next(m.radarID);
      stream.next(m.objectNum);
      stream.next(m.objectData);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ESR_Radar_Info_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::sensor::ESR_Radar_Info_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::sensor::ESR_Radar_Info_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "local_time: ";
    Printer<double>::stream(s, indent + "  ", v.local_time);
    s << indent << "gps_time: ";
    Printer<double>::stream(s, indent + "  ", v.gps_time);
    s << indent << "localposeStamped: ";
    s << std::endl;
    Printer< ::geometry_msgs::Pose2D_<ContainerAllocator> >::stream(s, indent + "  ", v.localposeStamped);
    s << indent << "radarID: ";
    Printer<int32_t>::stream(s, indent + "  ", v.radarID);
    s << indent << "objectNum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.objectNum);
    s << indent << "objectData[]" << std::endl;
    for (size_t i = 0; i < v.objectData.size(); ++i)
    {
      s << indent << "  objectData[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::sensor::ESR_Radar_Object_<ContainerAllocator> >::stream(s, indent + "    ", v.objectData[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // SENSOR_MESSAGE_ESR_RADAR_INFO_H
