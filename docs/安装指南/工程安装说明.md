## 工程框架简介：

**标准的“分层库架构（Layered Library Architecture）”**
- 每个模块都编译成 **库文件**
- 上一层模块：
    - 尽量 **不再编译实现**
    - 而是 **聚合其下的子模块**
- 形成：
    - 清晰的模块边界
    - 明确的依赖层级
- 效果：
    - 子模块只编译一次
    - 上层模块零重编译
    - 任意层级都可变成 `.so`

该工程由顶端的 `CMakeLists.txt` 控制，
```cmake
# 必须启用PIC，仅在极个别、明确边界的目标上关闭。
set(BUILD_SHARED_LIBS ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# 子模块
add_library(A_sub_sub ...)
# 自动 PIC

# 中间层
add_library(A_sub ...)
target_link_libraries(A_sub
    PUBLIC A_sub_sub
)

# 聚合层
add_library(A SHARED)
target_link_libraries(A
    PUBLIC A_sub
    PUBLIC B_sub_sub
)

# 通过注释的方式设置哪些模块编译与否
# add_subdirectory(modules) 
```

子模块中也有对应的 `add_subdirectory(programs)` 去设置

`cyber` 中的所有程序，只提供基础库文件，全部在程序内部自己输出 `bin` 

### CMAKE 指令简述

**`CMAKE_SOURCE_DIR` 和 `PROJECT_SOURCE_DIR`**

`CMAKE_SOURCE_DIR`：表示顶层的 CMake 项目目录。
它只在最顶层的 `CMakeLists.txt` 中指向当前目录。
如果在子目录中使用，`CMAKE_SOURCE_DIR` 依然指向顶层项目的源目录。

`PROJECT_SOURCE_DIR`：则是当前 `project()` 指令所在的目录。
对于顶层 `CMakeLists.txt` 中定义的项目，`PROJECT_SOURCE_DIR` 和 `CMAKE_SOURCE_DIR` 相同；
但是在子目录的 `CMakeLists.txt` 中，`PROJECT_SOURCE_DIR` 会指向该子项目的源目录。

**关于 `base.cmake` 的继承机制**

一旦在主目录的 `CMakeLists.txt` 中包含了 `base.cmake`，所有通过 `add_subdirectory` 添加的子目录都会自动继承 `base.cmake` 的配置。
这是因为 `CMake` 的变量和配置会在主目录定义后传播到子目录，确保每个子模块都能获得统一的编译设置。
如果某个子目录需要覆盖 `base.cmake` 中的某些配置（例如不同的编译选项），可以在该子目录的 `CMakeLists.txt` 中重新设置相应变量。

**其他指令**

- [CMAKE](基础库/cmake.md)

## 第三方库安装

- [必须库安装说明](必须库安装说明.md)

- [大型库安装说明](大型库安装说明.md)

## 编译调试顺序：

### Cyber RT

单步调试编译：
- base || common || context || proto || io_bridge || time || logger
- event || message || data || ( croutine || scheduler || task ) || sysmo || timer || class_loader
- service || fastdds || fastrtps || ( transport || statistics || service_discovery || blocker || node ) 
- component || Init.h || parameter || profiler
- record 

原始的 apollo代码， 大量使用了预编译库，依赖于系统一致性；

## 运行测试

详细见：
- [Debug](./Debug.md)

## docker 

20260111 开始，整个工程将基于 docker 进行分发。
详细见 [docker构建](./docker/docker构建.md)