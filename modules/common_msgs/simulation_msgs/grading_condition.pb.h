// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/common_msgs/simulation_msgs/grading_condition.proto

#ifndef PROTOBUF_INCLUDED_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto
#define PROTOBUF_INCLUDED_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/common_msgs/map_msgs/map_geometry.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto 

namespace protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[33];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto
namespace apollo {
namespace simulation {
class AbnormalStopCondition;
class AbnormalStopConditionDefaultTypeInternal;
extern AbnormalStopConditionDefaultTypeInternal _AbnormalStopCondition_default_instance_;
class AccelerationCondition;
class AccelerationConditionDefaultTypeInternal;
extern AccelerationConditionDefaultTypeInternal _AccelerationCondition_default_instance_;
class AntiCheatingCondition;
class AntiCheatingConditionDefaultTypeInternal;
extern AntiCheatingConditionDefaultTypeInternal _AntiCheatingCondition_default_instance_;
class BrakeTapCondition;
class BrakeTapConditionDefaultTypeInternal;
extern BrakeTapConditionDefaultTypeInternal _BrakeTapCondition_default_instance_;
class CentripetalAccelerationCondition;
class CentripetalAccelerationConditionDefaultTypeInternal;
extern CentripetalAccelerationConditionDefaultTypeInternal _CentripetalAccelerationCondition_default_instance_;
class ChangeLaneAtJunctionCondition;
class ChangeLaneAtJunctionConditionDefaultTypeInternal;
extern ChangeLaneAtJunctionConditionDefaultTypeInternal _ChangeLaneAtJunctionCondition_default_instance_;
class CheckpointCondition;
class CheckpointConditionDefaultTypeInternal;
extern CheckpointConditionDefaultTypeInternal _CheckpointCondition_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class CrosswalkStopCondition;
class CrosswalkStopConditionDefaultTypeInternal;
extern CrosswalkStopConditionDefaultTypeInternal _CrosswalkStopCondition_default_instance_;
class CrosswalkYieldCondition;
class CrosswalkYieldConditionDefaultTypeInternal;
extern CrosswalkYieldConditionDefaultTypeInternal _CrosswalkYieldCondition_default_instance_;
class DistToEndCondition;
class DistToEndConditionDefaultTypeInternal;
extern DistToEndConditionDefaultTypeInternal _DistToEndCondition_default_instance_;
class DistToLaneCenterCondition;
class DistToLaneCenterConditionDefaultTypeInternal;
extern DistToLaneCenterConditionDefaultTypeInternal _DistToLaneCenterCondition_default_instance_;
class FollowAndBypassCondition;
class FollowAndBypassConditionDefaultTypeInternal;
extern FollowAndBypassConditionDefaultTypeInternal _FollowAndBypassCondition_default_instance_;
class GradePlanning;
class GradePlanningDefaultTypeInternal;
extern GradePlanningDefaultTypeInternal _GradePlanning_default_instance_;
class JerkCondition;
class JerkConditionDefaultTypeInternal;
extern JerkConditionDefaultTypeInternal _JerkCondition_default_instance_;
class KeyPoint;
class KeyPointDefaultTypeInternal;
extern KeyPointDefaultTypeInternal _KeyPoint_default_instance_;
class KeyPointCondition;
class KeyPointConditionDefaultTypeInternal;
extern KeyPointConditionDefaultTypeInternal _KeyPointCondition_default_instance_;
class LimitedTimeParkingCondition;
class LimitedTimeParkingConditionDefaultTypeInternal;
extern LimitedTimeParkingConditionDefaultTypeInternal _LimitedTimeParkingCondition_default_instance_;
class LogicalCondition;
class LogicalConditionDefaultTypeInternal;
extern LogicalConditionDefaultTypeInternal _LogicalCondition_default_instance_;
class ObjectOverlapCondition;
class ObjectOverlapConditionDefaultTypeInternal;
extern ObjectOverlapConditionDefaultTypeInternal _ObjectOverlapCondition_default_instance_;
class ObstacleBypassCondition;
class ObstacleBypassConditionDefaultTypeInternal;
extern ObstacleBypassConditionDefaultTypeInternal _ObstacleBypassCondition_default_instance_;
class OnRoadCondition;
class OnRoadConditionDefaultTypeInternal;
extern OnRoadConditionDefaultTypeInternal _OnRoadCondition_default_instance_;
class RedLightStopCondition;
class RedLightStopConditionDefaultTypeInternal;
extern RedLightStopConditionDefaultTypeInternal _RedLightStopCondition_default_instance_;
class RegionOverlapCondition;
class RegionOverlapConditionDefaultTypeInternal;
extern RegionOverlapConditionDefaultTypeInternal _RegionOverlapCondition_default_instance_;
class RegionOverlapLWCondition;
class RegionOverlapLWConditionDefaultTypeInternal;
extern RegionOverlapLWConditionDefaultTypeInternal _RegionOverlapLWCondition_default_instance_;
class RoutingCondition;
class RoutingConditionDefaultTypeInternal;
extern RoutingConditionDefaultTypeInternal _RoutingCondition_default_instance_;
class RunRedLightCondition;
class RunRedLightConditionDefaultTypeInternal;
extern RunRedLightConditionDefaultTypeInternal _RunRedLightCondition_default_instance_;
class RunStopSignCondition;
class RunStopSignConditionDefaultTypeInternal;
extern RunStopSignConditionDefaultTypeInternal _RunStopSignCondition_default_instance_;
class SpeedCondition;
class SpeedConditionDefaultTypeInternal;
extern SpeedConditionDefaultTypeInternal _SpeedCondition_default_instance_;
class SpeedbumpLimitCondition;
class SpeedbumpLimitConditionDefaultTypeInternal;
extern SpeedbumpLimitConditionDefaultTypeInternal _SpeedbumpLimitCondition_default_instance_;
class SpinCondition;
class SpinConditionDefaultTypeInternal;
extern SpinConditionDefaultTypeInternal _SpinCondition_default_instance_;
class TimeLimitCondition;
class TimeLimitConditionDefaultTypeInternal;
extern TimeLimitConditionDefaultTypeInternal _TimeLimitCondition_default_instance_;
class WorkingZoneAvoidLimitCondition;
class WorkingZoneAvoidLimitConditionDefaultTypeInternal;
extern WorkingZoneAvoidLimitConditionDefaultTypeInternal _WorkingZoneAvoidLimitCondition_default_instance_;
}  // namespace simulation
}  // namespace apollo
namespace google {
namespace protobuf {
template<> ::apollo::simulation::AbnormalStopCondition* Arena::CreateMaybeMessage<::apollo::simulation::AbnormalStopCondition>(Arena*);
template<> ::apollo::simulation::AccelerationCondition* Arena::CreateMaybeMessage<::apollo::simulation::AccelerationCondition>(Arena*);
template<> ::apollo::simulation::AntiCheatingCondition* Arena::CreateMaybeMessage<::apollo::simulation::AntiCheatingCondition>(Arena*);
template<> ::apollo::simulation::BrakeTapCondition* Arena::CreateMaybeMessage<::apollo::simulation::BrakeTapCondition>(Arena*);
template<> ::apollo::simulation::CentripetalAccelerationCondition* Arena::CreateMaybeMessage<::apollo::simulation::CentripetalAccelerationCondition>(Arena*);
template<> ::apollo::simulation::ChangeLaneAtJunctionCondition* Arena::CreateMaybeMessage<::apollo::simulation::ChangeLaneAtJunctionCondition>(Arena*);
template<> ::apollo::simulation::CheckpointCondition* Arena::CreateMaybeMessage<::apollo::simulation::CheckpointCondition>(Arena*);
template<> ::apollo::simulation::Condition* Arena::CreateMaybeMessage<::apollo::simulation::Condition>(Arena*);
template<> ::apollo::simulation::CrosswalkStopCondition* Arena::CreateMaybeMessage<::apollo::simulation::CrosswalkStopCondition>(Arena*);
template<> ::apollo::simulation::CrosswalkYieldCondition* Arena::CreateMaybeMessage<::apollo::simulation::CrosswalkYieldCondition>(Arena*);
template<> ::apollo::simulation::DistToEndCondition* Arena::CreateMaybeMessage<::apollo::simulation::DistToEndCondition>(Arena*);
template<> ::apollo::simulation::DistToLaneCenterCondition* Arena::CreateMaybeMessage<::apollo::simulation::DistToLaneCenterCondition>(Arena*);
template<> ::apollo::simulation::FollowAndBypassCondition* Arena::CreateMaybeMessage<::apollo::simulation::FollowAndBypassCondition>(Arena*);
template<> ::apollo::simulation::GradePlanning* Arena::CreateMaybeMessage<::apollo::simulation::GradePlanning>(Arena*);
template<> ::apollo::simulation::JerkCondition* Arena::CreateMaybeMessage<::apollo::simulation::JerkCondition>(Arena*);
template<> ::apollo::simulation::KeyPoint* Arena::CreateMaybeMessage<::apollo::simulation::KeyPoint>(Arena*);
template<> ::apollo::simulation::KeyPointCondition* Arena::CreateMaybeMessage<::apollo::simulation::KeyPointCondition>(Arena*);
template<> ::apollo::simulation::LimitedTimeParkingCondition* Arena::CreateMaybeMessage<::apollo::simulation::LimitedTimeParkingCondition>(Arena*);
template<> ::apollo::simulation::LogicalCondition* Arena::CreateMaybeMessage<::apollo::simulation::LogicalCondition>(Arena*);
template<> ::apollo::simulation::ObjectOverlapCondition* Arena::CreateMaybeMessage<::apollo::simulation::ObjectOverlapCondition>(Arena*);
template<> ::apollo::simulation::ObstacleBypassCondition* Arena::CreateMaybeMessage<::apollo::simulation::ObstacleBypassCondition>(Arena*);
template<> ::apollo::simulation::OnRoadCondition* Arena::CreateMaybeMessage<::apollo::simulation::OnRoadCondition>(Arena*);
template<> ::apollo::simulation::RedLightStopCondition* Arena::CreateMaybeMessage<::apollo::simulation::RedLightStopCondition>(Arena*);
template<> ::apollo::simulation::RegionOverlapCondition* Arena::CreateMaybeMessage<::apollo::simulation::RegionOverlapCondition>(Arena*);
template<> ::apollo::simulation::RegionOverlapLWCondition* Arena::CreateMaybeMessage<::apollo::simulation::RegionOverlapLWCondition>(Arena*);
template<> ::apollo::simulation::RoutingCondition* Arena::CreateMaybeMessage<::apollo::simulation::RoutingCondition>(Arena*);
template<> ::apollo::simulation::RunRedLightCondition* Arena::CreateMaybeMessage<::apollo::simulation::RunRedLightCondition>(Arena*);
template<> ::apollo::simulation::RunStopSignCondition* Arena::CreateMaybeMessage<::apollo::simulation::RunStopSignCondition>(Arena*);
template<> ::apollo::simulation::SpeedCondition* Arena::CreateMaybeMessage<::apollo::simulation::SpeedCondition>(Arena*);
template<> ::apollo::simulation::SpeedbumpLimitCondition* Arena::CreateMaybeMessage<::apollo::simulation::SpeedbumpLimitCondition>(Arena*);
template<> ::apollo::simulation::SpinCondition* Arena::CreateMaybeMessage<::apollo::simulation::SpinCondition>(Arena*);
template<> ::apollo::simulation::TimeLimitCondition* Arena::CreateMaybeMessage<::apollo::simulation::TimeLimitCondition>(Arena*);
template<> ::apollo::simulation::WorkingZoneAvoidLimitCondition* Arena::CreateMaybeMessage<::apollo::simulation::WorkingZoneAvoidLimitCondition>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace apollo {
namespace simulation {

enum LogicalCondition_OperatorType {
  LogicalCondition_OperatorType_UNKNOWN = 0,
  LogicalCondition_OperatorType_NOT = 1,
  LogicalCondition_OperatorType_AND = 2,
  LogicalCondition_OperatorType_OR = 3,
  LogicalCondition_OperatorType_IMPLY = 4,
  LogicalCondition_OperatorType_XOR = 5
};
bool LogicalCondition_OperatorType_IsValid(int value);
const LogicalCondition_OperatorType LogicalCondition_OperatorType_OperatorType_MIN = LogicalCondition_OperatorType_UNKNOWN;
const LogicalCondition_OperatorType LogicalCondition_OperatorType_OperatorType_MAX = LogicalCondition_OperatorType_XOR;
const int LogicalCondition_OperatorType_OperatorType_ARRAYSIZE = LogicalCondition_OperatorType_OperatorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicalCondition_OperatorType_descriptor();
inline const ::std::string& LogicalCondition_OperatorType_Name(LogicalCondition_OperatorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicalCondition_OperatorType_descriptor(), value);
}
inline bool LogicalCondition_OperatorType_Parse(
    const ::std::string& name, LogicalCondition_OperatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicalCondition_OperatorType>(
    LogicalCondition_OperatorType_descriptor(), name, value);
}
enum ObjectOverlapCondition_DirectionType {
  ObjectOverlapCondition_DirectionType_EXCLUDE_BACK = 0,
  ObjectOverlapCondition_DirectionType_INCLUDE_BACK = 1
};
bool ObjectOverlapCondition_DirectionType_IsValid(int value);
const ObjectOverlapCondition_DirectionType ObjectOverlapCondition_DirectionType_DirectionType_MIN = ObjectOverlapCondition_DirectionType_EXCLUDE_BACK;
const ObjectOverlapCondition_DirectionType ObjectOverlapCondition_DirectionType_DirectionType_MAX = ObjectOverlapCondition_DirectionType_INCLUDE_BACK;
const int ObjectOverlapCondition_DirectionType_DirectionType_ARRAYSIZE = ObjectOverlapCondition_DirectionType_DirectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectOverlapCondition_DirectionType_descriptor();
inline const ::std::string& ObjectOverlapCondition_DirectionType_Name(ObjectOverlapCondition_DirectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectOverlapCondition_DirectionType_descriptor(), value);
}
inline bool ObjectOverlapCondition_DirectionType_Parse(
    const ::std::string& name, ObjectOverlapCondition_DirectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectOverlapCondition_DirectionType>(
    ObjectOverlapCondition_DirectionType_descriptor(), name, value);
}
// ===================================================================

class Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  enum ConditionCase {
    kLogicalCondition = 1,
    kSpeedCondition = 2,
    kAccelerationCondition = 3,
    kJerkCondition = 4,
    kObjectOverlapCondition = 5,
    kRegionOverlapCondition = 6,
    kRegionOverlapLwCondition = 7,
    kSpinCondition = 8,
    kOnRoadCondition = 9,
    kRunRedLightCondition = 10,
    kChangeLaneAtJunctionCondition = 11,
    kRoutingCondition = 12,
    kCrosswalkYieldCondition = 13,
    kAbnormalStopCondition = 14,
    kBrakeTapCondition = 15,
    kRunStopSignCondition = 16,
    kCheckpointCondition = 17,
    kDistToEndCondition = 18,
    kDistToLaneCenterCondition = 19,
    kCrosswalkStopCondition = 20,
    kRedLightStopCondition = 21,
    kSpeedbumpLimitCondition = 22,
    kWorkingZoneAvoidLimitCondition = 23,
    kLimitedTimeParkingCondition = 24,
    kFollowAndBypassCondition = 25,
    kObstacleBypassCondition = 26,
    kCentripetalAccelerationCondition = 27,
    kTimeLimitCondition = 28,
    kAntiCheatingCondition = 29,
    kKeyPointCondition = 30,
    CONDITION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(NULL);
  }

  Condition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.simulation.GradePlanning grade_planning = 100;
  bool has_grade_planning() const;
  void clear_grade_planning();
  static const int kGradePlanningFieldNumber = 100;
  private:
  const ::apollo::simulation::GradePlanning& _internal_grade_planning() const;
  public:
  const ::apollo::simulation::GradePlanning& grade_planning() const;
  ::apollo::simulation::GradePlanning* release_grade_planning();
  ::apollo::simulation::GradePlanning* mutable_grade_planning();
  void set_allocated_grade_planning(::apollo::simulation::GradePlanning* grade_planning);

  // optional .apollo.simulation.LogicalCondition logical_condition = 1;
  bool has_logical_condition() const;
  void clear_logical_condition();
  static const int kLogicalConditionFieldNumber = 1;
  private:
  const ::apollo::simulation::LogicalCondition& _internal_logical_condition() const;
  public:
  const ::apollo::simulation::LogicalCondition& logical_condition() const;
  ::apollo::simulation::LogicalCondition* release_logical_condition();
  ::apollo::simulation::LogicalCondition* mutable_logical_condition();
  void set_allocated_logical_condition(::apollo::simulation::LogicalCondition* logical_condition);

  // optional .apollo.simulation.SpeedCondition speed_condition = 2;
  bool has_speed_condition() const;
  void clear_speed_condition();
  static const int kSpeedConditionFieldNumber = 2;
  private:
  const ::apollo::simulation::SpeedCondition& _internal_speed_condition() const;
  public:
  const ::apollo::simulation::SpeedCondition& speed_condition() const;
  ::apollo::simulation::SpeedCondition* release_speed_condition();
  ::apollo::simulation::SpeedCondition* mutable_speed_condition();
  void set_allocated_speed_condition(::apollo::simulation::SpeedCondition* speed_condition);

  // optional .apollo.simulation.AccelerationCondition acceleration_condition = 3;
  bool has_acceleration_condition() const;
  void clear_acceleration_condition();
  static const int kAccelerationConditionFieldNumber = 3;
  private:
  const ::apollo::simulation::AccelerationCondition& _internal_acceleration_condition() const;
  public:
  const ::apollo::simulation::AccelerationCondition& acceleration_condition() const;
  ::apollo::simulation::AccelerationCondition* release_acceleration_condition();
  ::apollo::simulation::AccelerationCondition* mutable_acceleration_condition();
  void set_allocated_acceleration_condition(::apollo::simulation::AccelerationCondition* acceleration_condition);

  // optional .apollo.simulation.JerkCondition jerk_condition = 4;
  bool has_jerk_condition() const;
  void clear_jerk_condition();
  static const int kJerkConditionFieldNumber = 4;
  private:
  const ::apollo::simulation::JerkCondition& _internal_jerk_condition() const;
  public:
  const ::apollo::simulation::JerkCondition& jerk_condition() const;
  ::apollo::simulation::JerkCondition* release_jerk_condition();
  ::apollo::simulation::JerkCondition* mutable_jerk_condition();
  void set_allocated_jerk_condition(::apollo::simulation::JerkCondition* jerk_condition);

  // optional .apollo.simulation.ObjectOverlapCondition object_overlap_condition = 5;
  bool has_object_overlap_condition() const;
  void clear_object_overlap_condition();
  static const int kObjectOverlapConditionFieldNumber = 5;
  private:
  const ::apollo::simulation::ObjectOverlapCondition& _internal_object_overlap_condition() const;
  public:
  const ::apollo::simulation::ObjectOverlapCondition& object_overlap_condition() const;
  ::apollo::simulation::ObjectOverlapCondition* release_object_overlap_condition();
  ::apollo::simulation::ObjectOverlapCondition* mutable_object_overlap_condition();
  void set_allocated_object_overlap_condition(::apollo::simulation::ObjectOverlapCondition* object_overlap_condition);

  // optional .apollo.simulation.RegionOverlapCondition region_overlap_condition = 6;
  bool has_region_overlap_condition() const;
  void clear_region_overlap_condition();
  static const int kRegionOverlapConditionFieldNumber = 6;
  private:
  const ::apollo::simulation::RegionOverlapCondition& _internal_region_overlap_condition() const;
  public:
  const ::apollo::simulation::RegionOverlapCondition& region_overlap_condition() const;
  ::apollo::simulation::RegionOverlapCondition* release_region_overlap_condition();
  ::apollo::simulation::RegionOverlapCondition* mutable_region_overlap_condition();
  void set_allocated_region_overlap_condition(::apollo::simulation::RegionOverlapCondition* region_overlap_condition);

  // optional .apollo.simulation.RegionOverlapLWCondition region_overlap_lw_condition = 7;
  bool has_region_overlap_lw_condition() const;
  void clear_region_overlap_lw_condition();
  static const int kRegionOverlapLwConditionFieldNumber = 7;
  private:
  const ::apollo::simulation::RegionOverlapLWCondition& _internal_region_overlap_lw_condition() const;
  public:
  const ::apollo::simulation::RegionOverlapLWCondition& region_overlap_lw_condition() const;
  ::apollo::simulation::RegionOverlapLWCondition* release_region_overlap_lw_condition();
  ::apollo::simulation::RegionOverlapLWCondition* mutable_region_overlap_lw_condition();
  void set_allocated_region_overlap_lw_condition(::apollo::simulation::RegionOverlapLWCondition* region_overlap_lw_condition);

  // optional .apollo.simulation.SpinCondition spin_condition = 8;
  bool has_spin_condition() const;
  void clear_spin_condition();
  static const int kSpinConditionFieldNumber = 8;
  private:
  const ::apollo::simulation::SpinCondition& _internal_spin_condition() const;
  public:
  const ::apollo::simulation::SpinCondition& spin_condition() const;
  ::apollo::simulation::SpinCondition* release_spin_condition();
  ::apollo::simulation::SpinCondition* mutable_spin_condition();
  void set_allocated_spin_condition(::apollo::simulation::SpinCondition* spin_condition);

  // optional .apollo.simulation.OnRoadCondition on_road_condition = 9;
  bool has_on_road_condition() const;
  void clear_on_road_condition();
  static const int kOnRoadConditionFieldNumber = 9;
  private:
  const ::apollo::simulation::OnRoadCondition& _internal_on_road_condition() const;
  public:
  const ::apollo::simulation::OnRoadCondition& on_road_condition() const;
  ::apollo::simulation::OnRoadCondition* release_on_road_condition();
  ::apollo::simulation::OnRoadCondition* mutable_on_road_condition();
  void set_allocated_on_road_condition(::apollo::simulation::OnRoadCondition* on_road_condition);

  // optional .apollo.simulation.RunRedLightCondition run_red_light_condition = 10;
  bool has_run_red_light_condition() const;
  void clear_run_red_light_condition();
  static const int kRunRedLightConditionFieldNumber = 10;
  private:
  const ::apollo::simulation::RunRedLightCondition& _internal_run_red_light_condition() const;
  public:
  const ::apollo::simulation::RunRedLightCondition& run_red_light_condition() const;
  ::apollo::simulation::RunRedLightCondition* release_run_red_light_condition();
  ::apollo::simulation::RunRedLightCondition* mutable_run_red_light_condition();
  void set_allocated_run_red_light_condition(::apollo::simulation::RunRedLightCondition* run_red_light_condition);

  // optional .apollo.simulation.ChangeLaneAtJunctionCondition change_lane_at_junction_condition = 11;
  bool has_change_lane_at_junction_condition() const;
  void clear_change_lane_at_junction_condition();
  static const int kChangeLaneAtJunctionConditionFieldNumber = 11;
  private:
  const ::apollo::simulation::ChangeLaneAtJunctionCondition& _internal_change_lane_at_junction_condition() const;
  public:
  const ::apollo::simulation::ChangeLaneAtJunctionCondition& change_lane_at_junction_condition() const;
  ::apollo::simulation::ChangeLaneAtJunctionCondition* release_change_lane_at_junction_condition();
  ::apollo::simulation::ChangeLaneAtJunctionCondition* mutable_change_lane_at_junction_condition();
  void set_allocated_change_lane_at_junction_condition(::apollo::simulation::ChangeLaneAtJunctionCondition* change_lane_at_junction_condition);

  // optional .apollo.simulation.RoutingCondition routing_condition = 12;
  bool has_routing_condition() const;
  void clear_routing_condition();
  static const int kRoutingConditionFieldNumber = 12;
  private:
  const ::apollo::simulation::RoutingCondition& _internal_routing_condition() const;
  public:
  const ::apollo::simulation::RoutingCondition& routing_condition() const;
  ::apollo::simulation::RoutingCondition* release_routing_condition();
  ::apollo::simulation::RoutingCondition* mutable_routing_condition();
  void set_allocated_routing_condition(::apollo::simulation::RoutingCondition* routing_condition);

  // optional .apollo.simulation.CrosswalkYieldCondition crosswalk_yield_condition = 13;
  bool has_crosswalk_yield_condition() const;
  void clear_crosswalk_yield_condition();
  static const int kCrosswalkYieldConditionFieldNumber = 13;
  private:
  const ::apollo::simulation::CrosswalkYieldCondition& _internal_crosswalk_yield_condition() const;
  public:
  const ::apollo::simulation::CrosswalkYieldCondition& crosswalk_yield_condition() const;
  ::apollo::simulation::CrosswalkYieldCondition* release_crosswalk_yield_condition();
  ::apollo::simulation::CrosswalkYieldCondition* mutable_crosswalk_yield_condition();
  void set_allocated_crosswalk_yield_condition(::apollo::simulation::CrosswalkYieldCondition* crosswalk_yield_condition);

  // optional .apollo.simulation.AbnormalStopCondition abnormal_stop_condition = 14;
  bool has_abnormal_stop_condition() const;
  void clear_abnormal_stop_condition();
  static const int kAbnormalStopConditionFieldNumber = 14;
  private:
  const ::apollo::simulation::AbnormalStopCondition& _internal_abnormal_stop_condition() const;
  public:
  const ::apollo::simulation::AbnormalStopCondition& abnormal_stop_condition() const;
  ::apollo::simulation::AbnormalStopCondition* release_abnormal_stop_condition();
  ::apollo::simulation::AbnormalStopCondition* mutable_abnormal_stop_condition();
  void set_allocated_abnormal_stop_condition(::apollo::simulation::AbnormalStopCondition* abnormal_stop_condition);

  // optional .apollo.simulation.BrakeTapCondition brake_tap_condition = 15;
  bool has_brake_tap_condition() const;
  void clear_brake_tap_condition();
  static const int kBrakeTapConditionFieldNumber = 15;
  private:
  const ::apollo::simulation::BrakeTapCondition& _internal_brake_tap_condition() const;
  public:
  const ::apollo::simulation::BrakeTapCondition& brake_tap_condition() const;
  ::apollo::simulation::BrakeTapCondition* release_brake_tap_condition();
  ::apollo::simulation::BrakeTapCondition* mutable_brake_tap_condition();
  void set_allocated_brake_tap_condition(::apollo::simulation::BrakeTapCondition* brake_tap_condition);

  // optional .apollo.simulation.RunStopSignCondition run_stop_sign_condition = 16;
  bool has_run_stop_sign_condition() const;
  void clear_run_stop_sign_condition();
  static const int kRunStopSignConditionFieldNumber = 16;
  private:
  const ::apollo::simulation::RunStopSignCondition& _internal_run_stop_sign_condition() const;
  public:
  const ::apollo::simulation::RunStopSignCondition& run_stop_sign_condition() const;
  ::apollo::simulation::RunStopSignCondition* release_run_stop_sign_condition();
  ::apollo::simulation::RunStopSignCondition* mutable_run_stop_sign_condition();
  void set_allocated_run_stop_sign_condition(::apollo::simulation::RunStopSignCondition* run_stop_sign_condition);

  // optional .apollo.simulation.CheckpointCondition checkpoint_condition = 17;
  bool has_checkpoint_condition() const;
  void clear_checkpoint_condition();
  static const int kCheckpointConditionFieldNumber = 17;
  private:
  const ::apollo::simulation::CheckpointCondition& _internal_checkpoint_condition() const;
  public:
  const ::apollo::simulation::CheckpointCondition& checkpoint_condition() const;
  ::apollo::simulation::CheckpointCondition* release_checkpoint_condition();
  ::apollo::simulation::CheckpointCondition* mutable_checkpoint_condition();
  void set_allocated_checkpoint_condition(::apollo::simulation::CheckpointCondition* checkpoint_condition);

  // optional .apollo.simulation.DistToEndCondition dist_to_end_condition = 18;
  bool has_dist_to_end_condition() const;
  void clear_dist_to_end_condition();
  static const int kDistToEndConditionFieldNumber = 18;
  private:
  const ::apollo::simulation::DistToEndCondition& _internal_dist_to_end_condition() const;
  public:
  const ::apollo::simulation::DistToEndCondition& dist_to_end_condition() const;
  ::apollo::simulation::DistToEndCondition* release_dist_to_end_condition();
  ::apollo::simulation::DistToEndCondition* mutable_dist_to_end_condition();
  void set_allocated_dist_to_end_condition(::apollo::simulation::DistToEndCondition* dist_to_end_condition);

  // optional .apollo.simulation.DistToLaneCenterCondition dist_to_lane_center_condition = 19;
  bool has_dist_to_lane_center_condition() const;
  void clear_dist_to_lane_center_condition();
  static const int kDistToLaneCenterConditionFieldNumber = 19;
  private:
  const ::apollo::simulation::DistToLaneCenterCondition& _internal_dist_to_lane_center_condition() const;
  public:
  const ::apollo::simulation::DistToLaneCenterCondition& dist_to_lane_center_condition() const;
  ::apollo::simulation::DistToLaneCenterCondition* release_dist_to_lane_center_condition();
  ::apollo::simulation::DistToLaneCenterCondition* mutable_dist_to_lane_center_condition();
  void set_allocated_dist_to_lane_center_condition(::apollo::simulation::DistToLaneCenterCondition* dist_to_lane_center_condition);

  // optional .apollo.simulation.CrosswalkStopCondition crosswalk_stop_condition = 20;
  bool has_crosswalk_stop_condition() const;
  void clear_crosswalk_stop_condition();
  static const int kCrosswalkStopConditionFieldNumber = 20;
  private:
  const ::apollo::simulation::CrosswalkStopCondition& _internal_crosswalk_stop_condition() const;
  public:
  const ::apollo::simulation::CrosswalkStopCondition& crosswalk_stop_condition() const;
  ::apollo::simulation::CrosswalkStopCondition* release_crosswalk_stop_condition();
  ::apollo::simulation::CrosswalkStopCondition* mutable_crosswalk_stop_condition();
  void set_allocated_crosswalk_stop_condition(::apollo::simulation::CrosswalkStopCondition* crosswalk_stop_condition);

  // optional .apollo.simulation.RedLightStopCondition red_light_stop_condition = 21;
  bool has_red_light_stop_condition() const;
  void clear_red_light_stop_condition();
  static const int kRedLightStopConditionFieldNumber = 21;
  private:
  const ::apollo::simulation::RedLightStopCondition& _internal_red_light_stop_condition() const;
  public:
  const ::apollo::simulation::RedLightStopCondition& red_light_stop_condition() const;
  ::apollo::simulation::RedLightStopCondition* release_red_light_stop_condition();
  ::apollo::simulation::RedLightStopCondition* mutable_red_light_stop_condition();
  void set_allocated_red_light_stop_condition(::apollo::simulation::RedLightStopCondition* red_light_stop_condition);

  // optional .apollo.simulation.SpeedbumpLimitCondition speedbump_limit_condition = 22;
  bool has_speedbump_limit_condition() const;
  void clear_speedbump_limit_condition();
  static const int kSpeedbumpLimitConditionFieldNumber = 22;
  private:
  const ::apollo::simulation::SpeedbumpLimitCondition& _internal_speedbump_limit_condition() const;
  public:
  const ::apollo::simulation::SpeedbumpLimitCondition& speedbump_limit_condition() const;
  ::apollo::simulation::SpeedbumpLimitCondition* release_speedbump_limit_condition();
  ::apollo::simulation::SpeedbumpLimitCondition* mutable_speedbump_limit_condition();
  void set_allocated_speedbump_limit_condition(::apollo::simulation::SpeedbumpLimitCondition* speedbump_limit_condition);

  // optional .apollo.simulation.WorkingZoneAvoidLimitCondition working_zone_avoid_limit_condition = 23;
  bool has_working_zone_avoid_limit_condition() const;
  void clear_working_zone_avoid_limit_condition();
  static const int kWorkingZoneAvoidLimitConditionFieldNumber = 23;
  private:
  const ::apollo::simulation::WorkingZoneAvoidLimitCondition& _internal_working_zone_avoid_limit_condition() const;
  public:
  const ::apollo::simulation::WorkingZoneAvoidLimitCondition& working_zone_avoid_limit_condition() const;
  ::apollo::simulation::WorkingZoneAvoidLimitCondition* release_working_zone_avoid_limit_condition();
  ::apollo::simulation::WorkingZoneAvoidLimitCondition* mutable_working_zone_avoid_limit_condition();
  void set_allocated_working_zone_avoid_limit_condition(::apollo::simulation::WorkingZoneAvoidLimitCondition* working_zone_avoid_limit_condition);

  // optional .apollo.simulation.LimitedTimeParkingCondition limited_time_parking_condition = 24;
  bool has_limited_time_parking_condition() const;
  void clear_limited_time_parking_condition();
  static const int kLimitedTimeParkingConditionFieldNumber = 24;
  private:
  const ::apollo::simulation::LimitedTimeParkingCondition& _internal_limited_time_parking_condition() const;
  public:
  const ::apollo::simulation::LimitedTimeParkingCondition& limited_time_parking_condition() const;
  ::apollo::simulation::LimitedTimeParkingCondition* release_limited_time_parking_condition();
  ::apollo::simulation::LimitedTimeParkingCondition* mutable_limited_time_parking_condition();
  void set_allocated_limited_time_parking_condition(::apollo::simulation::LimitedTimeParkingCondition* limited_time_parking_condition);

  // optional .apollo.simulation.FollowAndBypassCondition follow_and_bypass_condition = 25;
  bool has_follow_and_bypass_condition() const;
  void clear_follow_and_bypass_condition();
  static const int kFollowAndBypassConditionFieldNumber = 25;
  private:
  const ::apollo::simulation::FollowAndBypassCondition& _internal_follow_and_bypass_condition() const;
  public:
  const ::apollo::simulation::FollowAndBypassCondition& follow_and_bypass_condition() const;
  ::apollo::simulation::FollowAndBypassCondition* release_follow_and_bypass_condition();
  ::apollo::simulation::FollowAndBypassCondition* mutable_follow_and_bypass_condition();
  void set_allocated_follow_and_bypass_condition(::apollo::simulation::FollowAndBypassCondition* follow_and_bypass_condition);

  // optional .apollo.simulation.ObstacleBypassCondition obstacle_bypass_condition = 26;
  bool has_obstacle_bypass_condition() const;
  void clear_obstacle_bypass_condition();
  static const int kObstacleBypassConditionFieldNumber = 26;
  private:
  const ::apollo::simulation::ObstacleBypassCondition& _internal_obstacle_bypass_condition() const;
  public:
  const ::apollo::simulation::ObstacleBypassCondition& obstacle_bypass_condition() const;
  ::apollo::simulation::ObstacleBypassCondition* release_obstacle_bypass_condition();
  ::apollo::simulation::ObstacleBypassCondition* mutable_obstacle_bypass_condition();
  void set_allocated_obstacle_bypass_condition(::apollo::simulation::ObstacleBypassCondition* obstacle_bypass_condition);

  // optional .apollo.simulation.CentripetalAccelerationCondition centripetal_acceleration_condition = 27;
  bool has_centripetal_acceleration_condition() const;
  void clear_centripetal_acceleration_condition();
  static const int kCentripetalAccelerationConditionFieldNumber = 27;
  private:
  const ::apollo::simulation::CentripetalAccelerationCondition& _internal_centripetal_acceleration_condition() const;
  public:
  const ::apollo::simulation::CentripetalAccelerationCondition& centripetal_acceleration_condition() const;
  ::apollo::simulation::CentripetalAccelerationCondition* release_centripetal_acceleration_condition();
  ::apollo::simulation::CentripetalAccelerationCondition* mutable_centripetal_acceleration_condition();
  void set_allocated_centripetal_acceleration_condition(::apollo::simulation::CentripetalAccelerationCondition* centripetal_acceleration_condition);

  // optional .apollo.simulation.TimeLimitCondition time_limit_condition = 28;
  bool has_time_limit_condition() const;
  void clear_time_limit_condition();
  static const int kTimeLimitConditionFieldNumber = 28;
  private:
  const ::apollo::simulation::TimeLimitCondition& _internal_time_limit_condition() const;
  public:
  const ::apollo::simulation::TimeLimitCondition& time_limit_condition() const;
  ::apollo::simulation::TimeLimitCondition* release_time_limit_condition();
  ::apollo::simulation::TimeLimitCondition* mutable_time_limit_condition();
  void set_allocated_time_limit_condition(::apollo::simulation::TimeLimitCondition* time_limit_condition);

  // optional .apollo.simulation.AntiCheatingCondition anti_cheating_condition = 29;
  bool has_anti_cheating_condition() const;
  void clear_anti_cheating_condition();
  static const int kAntiCheatingConditionFieldNumber = 29;
  private:
  const ::apollo::simulation::AntiCheatingCondition& _internal_anti_cheating_condition() const;
  public:
  const ::apollo::simulation::AntiCheatingCondition& anti_cheating_condition() const;
  ::apollo::simulation::AntiCheatingCondition* release_anti_cheating_condition();
  ::apollo::simulation::AntiCheatingCondition* mutable_anti_cheating_condition();
  void set_allocated_anti_cheating_condition(::apollo::simulation::AntiCheatingCondition* anti_cheating_condition);

  // optional .apollo.simulation.KeyPointCondition key_point_condition = 30;
  bool has_key_point_condition() const;
  void clear_key_point_condition();
  static const int kKeyPointConditionFieldNumber = 30;
  private:
  const ::apollo::simulation::KeyPointCondition& _internal_key_point_condition() const;
  public:
  const ::apollo::simulation::KeyPointCondition& key_point_condition() const;
  ::apollo::simulation::KeyPointCondition* release_key_point_condition();
  ::apollo::simulation::KeyPointCondition* mutable_key_point_condition();
  void set_allocated_key_point_condition(::apollo::simulation::KeyPointCondition* key_point_condition);

  void clear_condition();
  ConditionCase condition_case() const;
  // @@protoc_insertion_point(class_scope:apollo.simulation.Condition)
 private:
  void set_has_logical_condition();
  void set_has_speed_condition();
  void set_has_acceleration_condition();
  void set_has_jerk_condition();
  void set_has_object_overlap_condition();
  void set_has_region_overlap_condition();
  void set_has_region_overlap_lw_condition();
  void set_has_spin_condition();
  void set_has_on_road_condition();
  void set_has_run_red_light_condition();
  void set_has_change_lane_at_junction_condition();
  void set_has_routing_condition();
  void set_has_crosswalk_yield_condition();
  void set_has_abnormal_stop_condition();
  void set_has_brake_tap_condition();
  void set_has_run_stop_sign_condition();
  void set_has_checkpoint_condition();
  void set_has_dist_to_end_condition();
  void set_has_dist_to_lane_center_condition();
  void set_has_crosswalk_stop_condition();
  void set_has_red_light_stop_condition();
  void set_has_speedbump_limit_condition();
  void set_has_working_zone_avoid_limit_condition();
  void set_has_limited_time_parking_condition();
  void set_has_follow_and_bypass_condition();
  void set_has_obstacle_bypass_condition();
  void set_has_centripetal_acceleration_condition();
  void set_has_time_limit_condition();
  void set_has_anti_cheating_condition();
  void set_has_key_point_condition();
  void set_has_grade_planning();
  void clear_has_grade_planning();

  inline bool has_condition() const;
  inline void clear_has_condition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::simulation::GradePlanning* grade_planning_;
  union ConditionUnion {
    ConditionUnion() {}
    ::apollo::simulation::LogicalCondition* logical_condition_;
    ::apollo::simulation::SpeedCondition* speed_condition_;
    ::apollo::simulation::AccelerationCondition* acceleration_condition_;
    ::apollo::simulation::JerkCondition* jerk_condition_;
    ::apollo::simulation::ObjectOverlapCondition* object_overlap_condition_;
    ::apollo::simulation::RegionOverlapCondition* region_overlap_condition_;
    ::apollo::simulation::RegionOverlapLWCondition* region_overlap_lw_condition_;
    ::apollo::simulation::SpinCondition* spin_condition_;
    ::apollo::simulation::OnRoadCondition* on_road_condition_;
    ::apollo::simulation::RunRedLightCondition* run_red_light_condition_;
    ::apollo::simulation::ChangeLaneAtJunctionCondition* change_lane_at_junction_condition_;
    ::apollo::simulation::RoutingCondition* routing_condition_;
    ::apollo::simulation::CrosswalkYieldCondition* crosswalk_yield_condition_;
    ::apollo::simulation::AbnormalStopCondition* abnormal_stop_condition_;
    ::apollo::simulation::BrakeTapCondition* brake_tap_condition_;
    ::apollo::simulation::RunStopSignCondition* run_stop_sign_condition_;
    ::apollo::simulation::CheckpointCondition* checkpoint_condition_;
    ::apollo::simulation::DistToEndCondition* dist_to_end_condition_;
    ::apollo::simulation::DistToLaneCenterCondition* dist_to_lane_center_condition_;
    ::apollo::simulation::CrosswalkStopCondition* crosswalk_stop_condition_;
    ::apollo::simulation::RedLightStopCondition* red_light_stop_condition_;
    ::apollo::simulation::SpeedbumpLimitCondition* speedbump_limit_condition_;
    ::apollo::simulation::WorkingZoneAvoidLimitCondition* working_zone_avoid_limit_condition_;
    ::apollo::simulation::LimitedTimeParkingCondition* limited_time_parking_condition_;
    ::apollo::simulation::FollowAndBypassCondition* follow_and_bypass_condition_;
    ::apollo::simulation::ObstacleBypassCondition* obstacle_bypass_condition_;
    ::apollo::simulation::CentripetalAccelerationCondition* centripetal_acceleration_condition_;
    ::apollo::simulation::TimeLimitCondition* time_limit_condition_;
    ::apollo::simulation::AntiCheatingCondition* anti_cheating_condition_;
    ::apollo::simulation::KeyPointCondition* key_point_condition_;
  } condition_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GradePlanning : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.GradePlanning) */ {
 public:
  GradePlanning();
  virtual ~GradePlanning();

  GradePlanning(const GradePlanning& from);

  inline GradePlanning& operator=(const GradePlanning& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GradePlanning(GradePlanning&& from) noexcept
    : GradePlanning() {
    *this = ::std::move(from);
  }

  inline GradePlanning& operator=(GradePlanning&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GradePlanning& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GradePlanning* internal_default_instance() {
    return reinterpret_cast<const GradePlanning*>(
               &_GradePlanning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GradePlanning* other);
  friend void swap(GradePlanning& a, GradePlanning& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GradePlanning* New() const final {
    return CreateMaybeMessage<GradePlanning>(NULL);
  }

  GradePlanning* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GradePlanning>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GradePlanning& from);
  void MergeFrom(const GradePlanning& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradePlanning* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 duration = 1 [default = 0];
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::int32 duration() const;
  void set_duration(::google::protobuf::int32 value);

  // optional bool update_obstacles = 2 [default = false];
  bool has_update_obstacles() const;
  void clear_update_obstacles();
  static const int kUpdateObstaclesFieldNumber = 2;
  bool update_obstacles() const;
  void set_update_obstacles(bool value);

  // optional bool use_planning_as_history = 3 [default = false];
  bool has_use_planning_as_history() const;
  void clear_use_planning_as_history();
  static const int kUsePlanningAsHistoryFieldNumber = 3;
  bool use_planning_as_history() const;
  void set_use_planning_as_history(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.GradePlanning)
 private:
  void set_has_duration();
  void clear_has_duration();
  void set_has_update_obstacles();
  void clear_has_update_obstacles();
  void set_has_use_planning_as_history();
  void clear_has_use_planning_as_history();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 duration_;
  bool update_obstacles_;
  bool use_planning_as_history_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.LogicalCondition) */ {
 public:
  LogicalCondition();
  virtual ~LogicalCondition();

  LogicalCondition(const LogicalCondition& from);

  inline LogicalCondition& operator=(const LogicalCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalCondition(LogicalCondition&& from) noexcept
    : LogicalCondition() {
    *this = ::std::move(from);
  }

  inline LogicalCondition& operator=(LogicalCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalCondition* internal_default_instance() {
    return reinterpret_cast<const LogicalCondition*>(
               &_LogicalCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LogicalCondition* other);
  friend void swap(LogicalCondition& a, LogicalCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalCondition* New() const final {
    return CreateMaybeMessage<LogicalCondition>(NULL);
  }

  LogicalCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalCondition& from);
  void MergeFrom(const LogicalCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogicalCondition_OperatorType OperatorType;
  static const OperatorType UNKNOWN =
    LogicalCondition_OperatorType_UNKNOWN;
  static const OperatorType NOT =
    LogicalCondition_OperatorType_NOT;
  static const OperatorType AND =
    LogicalCondition_OperatorType_AND;
  static const OperatorType OR =
    LogicalCondition_OperatorType_OR;
  static const OperatorType IMPLY =
    LogicalCondition_OperatorType_IMPLY;
  static const OperatorType XOR =
    LogicalCondition_OperatorType_XOR;
  static inline bool OperatorType_IsValid(int value) {
    return LogicalCondition_OperatorType_IsValid(value);
  }
  static const OperatorType OperatorType_MIN =
    LogicalCondition_OperatorType_OperatorType_MIN;
  static const OperatorType OperatorType_MAX =
    LogicalCondition_OperatorType_OperatorType_MAX;
  static const int OperatorType_ARRAYSIZE =
    LogicalCondition_OperatorType_OperatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperatorType_descriptor() {
    return LogicalCondition_OperatorType_descriptor();
  }
  static inline const ::std::string& OperatorType_Name(OperatorType value) {
    return LogicalCondition_OperatorType_Name(value);
  }
  static inline bool OperatorType_Parse(const ::std::string& name,
      OperatorType* value) {
    return LogicalCondition_OperatorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .apollo.simulation.Condition sub_condition = 2;
  int sub_condition_size() const;
  void clear_sub_condition();
  static const int kSubConditionFieldNumber = 2;
  ::apollo::simulation::Condition* mutable_sub_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >*
      mutable_sub_condition();
  const ::apollo::simulation::Condition& sub_condition(int index) const;
  ::apollo::simulation::Condition* add_sub_condition();
  const ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >&
      sub_condition() const;

  // optional .apollo.simulation.LogicalCondition.OperatorType operator_type = 1;
  bool has_operator_type() const;
  void clear_operator_type();
  static const int kOperatorTypeFieldNumber = 1;
  ::apollo::simulation::LogicalCondition_OperatorType operator_type() const;
  void set_operator_type(::apollo::simulation::LogicalCondition_OperatorType value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.LogicalCondition)
 private:
  void set_has_operator_type();
  void clear_has_operator_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition > sub_condition_;
  int operator_type_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.SpeedCondition) */ {
 public:
  SpeedCondition();
  virtual ~SpeedCondition();

  SpeedCondition(const SpeedCondition& from);

  inline SpeedCondition& operator=(const SpeedCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedCondition(SpeedCondition&& from) noexcept
    : SpeedCondition() {
    *this = ::std::move(from);
  }

  inline SpeedCondition& operator=(SpeedCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedCondition* internal_default_instance() {
    return reinterpret_cast<const SpeedCondition*>(
               &_SpeedCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SpeedCondition* other);
  friend void swap(SpeedCondition& a, SpeedCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedCondition* New() const final {
    return CreateMaybeMessage<SpeedCondition>(NULL);
  }

  SpeedCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeedCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeedCondition& from);
  void MergeFrom(const SpeedCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "speed"];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 4;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double min_speed = 2 [default = -0.5];
  bool has_min_speed() const;
  void clear_min_speed();
  static const int kMinSpeedFieldNumber = 2;
  double min_speed() const;
  void set_min_speed(double value);

  // optional double max_speed = 3 [default = 1000];
  bool has_max_speed() const;
  void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 3;
  double max_speed() const;
  void set_max_speed(double value);

  // optional double single_deduction = 5 [default = 0.5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 5;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.SpeedCondition)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_min_speed();
  void clear_has_min_speed();
  void set_has_max_speed();
  void clear_has_max_speed();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool use_score_;
  double min_speed_;
  double max_speed_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CentripetalAccelerationCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CentripetalAccelerationCondition) */ {
 public:
  CentripetalAccelerationCondition();
  virtual ~CentripetalAccelerationCondition();

  CentripetalAccelerationCondition(const CentripetalAccelerationCondition& from);

  inline CentripetalAccelerationCondition& operator=(const CentripetalAccelerationCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CentripetalAccelerationCondition(CentripetalAccelerationCondition&& from) noexcept
    : CentripetalAccelerationCondition() {
    *this = ::std::move(from);
  }

  inline CentripetalAccelerationCondition& operator=(CentripetalAccelerationCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CentripetalAccelerationCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CentripetalAccelerationCondition* internal_default_instance() {
    return reinterpret_cast<const CentripetalAccelerationCondition*>(
               &_CentripetalAccelerationCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CentripetalAccelerationCondition* other);
  friend void swap(CentripetalAccelerationCondition& a, CentripetalAccelerationCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CentripetalAccelerationCondition* New() const final {
    return CreateMaybeMessage<CentripetalAccelerationCondition>(NULL);
  }

  CentripetalAccelerationCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CentripetalAccelerationCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CentripetalAccelerationCondition& from);
  void MergeFrom(const CentripetalAccelerationCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CentripetalAccelerationCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "centripetal_acceleration"];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool use_score = 3 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 3;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double max_centripetal_acceleration = 2 [default = 2];
  bool has_max_centripetal_acceleration() const;
  void clear_max_centripetal_acceleration();
  static const int kMaxCentripetalAccelerationFieldNumber = 2;
  double max_centripetal_acceleration() const;
  void set_max_centripetal_acceleration(double value);

  // optional double single_deduction = 4 [default = 0.5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 4;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.CentripetalAccelerationCondition)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_max_centripetal_acceleration();
  void clear_has_max_centripetal_acceleration();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool use_score_;
  double max_centripetal_acceleration_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccelerationCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.AccelerationCondition) */ {
 public:
  AccelerationCondition();
  virtual ~AccelerationCondition();

  AccelerationCondition(const AccelerationCondition& from);

  inline AccelerationCondition& operator=(const AccelerationCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccelerationCondition(AccelerationCondition&& from) noexcept
    : AccelerationCondition() {
    *this = ::std::move(from);
  }

  inline AccelerationCondition& operator=(AccelerationCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccelerationCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccelerationCondition* internal_default_instance() {
    return reinterpret_cast<const AccelerationCondition*>(
               &_AccelerationCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AccelerationCondition* other);
  friend void swap(AccelerationCondition& a, AccelerationCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccelerationCondition* New() const final {
    return CreateMaybeMessage<AccelerationCondition>(NULL);
  }

  AccelerationCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccelerationCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccelerationCondition& from);
  void MergeFrom(const AccelerationCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "acceleration"];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 4;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double min_acceleration = 2 [default = -1000];
  bool has_min_acceleration() const;
  void clear_min_acceleration();
  static const int kMinAccelerationFieldNumber = 2;
  double min_acceleration() const;
  void set_min_acceleration(double value);

  // optional double max_acceleration = 3 [default = 1000];
  bool has_max_acceleration() const;
  void clear_max_acceleration();
  static const int kMaxAccelerationFieldNumber = 3;
  double max_acceleration() const;
  void set_max_acceleration(double value);

  // optional double single_deduction = 5 [default = 0.5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 5;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.AccelerationCondition)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_min_acceleration();
  void clear_has_min_acceleration();
  void set_has_max_acceleration();
  void clear_has_max_acceleration();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool use_score_;
  double min_acceleration_;
  double max_acceleration_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JerkCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.JerkCondition) */ {
 public:
  JerkCondition();
  virtual ~JerkCondition();

  JerkCondition(const JerkCondition& from);

  inline JerkCondition& operator=(const JerkCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JerkCondition(JerkCondition&& from) noexcept
    : JerkCondition() {
    *this = ::std::move(from);
  }

  inline JerkCondition& operator=(JerkCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JerkCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JerkCondition* internal_default_instance() {
    return reinterpret_cast<const JerkCondition*>(
               &_JerkCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(JerkCondition* other);
  friend void swap(JerkCondition& a, JerkCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JerkCondition* New() const final {
    return CreateMaybeMessage<JerkCondition>(NULL);
  }

  JerkCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JerkCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JerkCondition& from);
  void MergeFrom(const JerkCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JerkCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "jerk"];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional double min_jerk = 2 [default = -1000];
  bool has_min_jerk() const;
  void clear_min_jerk();
  static const int kMinJerkFieldNumber = 2;
  double min_jerk() const;
  void set_min_jerk(double value);

  // optional double max_jerk = 3 [default = 1000];
  bool has_max_jerk() const;
  void clear_max_jerk();
  static const int kMaxJerkFieldNumber = 3;
  double max_jerk() const;
  void set_max_jerk(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.JerkCondition)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_min_jerk();
  void clear_has_min_jerk();
  void set_has_max_jerk();
  void clear_has_max_jerk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr name_;
  double min_jerk_;
  double max_jerk_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpinCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.SpinCondition) */ {
 public:
  SpinCondition();
  virtual ~SpinCondition();

  SpinCondition(const SpinCondition& from);

  inline SpinCondition& operator=(const SpinCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpinCondition(SpinCondition&& from) noexcept
    : SpinCondition() {
    *this = ::std::move(from);
  }

  inline SpinCondition& operator=(SpinCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpinCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpinCondition* internal_default_instance() {
    return reinterpret_cast<const SpinCondition*>(
               &_SpinCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SpinCondition* other);
  friend void swap(SpinCondition& a, SpinCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpinCondition* New() const final {
    return CreateMaybeMessage<SpinCondition>(NULL);
  }

  SpinCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpinCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpinCondition& from);
  void MergeFrom(const SpinCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpinCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1 [default = "spin"];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional double min_spin = 2 [default = -1000];
  bool has_min_spin() const;
  void clear_min_spin();
  static const int kMinSpinFieldNumber = 2;
  double min_spin() const;
  void set_min_spin(double value);

  // optional double max_spin = 3 [default = 1000];
  bool has_max_spin() const;
  void clear_max_spin();
  static const int kMaxSpinFieldNumber = 3;
  double max_spin() const;
  void set_max_spin(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.SpinCondition)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_min_spin();
  void clear_has_min_spin();
  void set_has_max_spin();
  void clear_has_max_spin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_name_;
  private:
  ::google::protobuf::internal::ArenaStringPtr name_;
  double min_spin_;
  double max_spin_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectOverlapCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.ObjectOverlapCondition) */ {
 public:
  ObjectOverlapCondition();
  virtual ~ObjectOverlapCondition();

  ObjectOverlapCondition(const ObjectOverlapCondition& from);

  inline ObjectOverlapCondition& operator=(const ObjectOverlapCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectOverlapCondition(ObjectOverlapCondition&& from) noexcept
    : ObjectOverlapCondition() {
    *this = ::std::move(from);
  }

  inline ObjectOverlapCondition& operator=(ObjectOverlapCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectOverlapCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectOverlapCondition* internal_default_instance() {
    return reinterpret_cast<const ObjectOverlapCondition*>(
               &_ObjectOverlapCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ObjectOverlapCondition* other);
  friend void swap(ObjectOverlapCondition& a, ObjectOverlapCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectOverlapCondition* New() const final {
    return CreateMaybeMessage<ObjectOverlapCondition>(NULL);
  }

  ObjectOverlapCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectOverlapCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectOverlapCondition& from);
  void MergeFrom(const ObjectOverlapCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOverlapCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ObjectOverlapCondition_DirectionType DirectionType;
  static const DirectionType EXCLUDE_BACK =
    ObjectOverlapCondition_DirectionType_EXCLUDE_BACK;
  static const DirectionType INCLUDE_BACK =
    ObjectOverlapCondition_DirectionType_INCLUDE_BACK;
  static inline bool DirectionType_IsValid(int value) {
    return ObjectOverlapCondition_DirectionType_IsValid(value);
  }
  static const DirectionType DirectionType_MIN =
    ObjectOverlapCondition_DirectionType_DirectionType_MIN;
  static const DirectionType DirectionType_MAX =
    ObjectOverlapCondition_DirectionType_DirectionType_MAX;
  static const int DirectionType_ARRAYSIZE =
    ObjectOverlapCondition_DirectionType_DirectionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DirectionType_descriptor() {
    return ObjectOverlapCondition_DirectionType_descriptor();
  }
  static inline const ::std::string& DirectionType_Name(DirectionType value) {
    return ObjectOverlapCondition_DirectionType_Name(value);
  }
  static inline bool DirectionType_Parse(const ::std::string& name,
      DirectionType* value) {
    return ObjectOverlapCondition_DirectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string ignore_object_ids = 5;
  int ignore_object_ids_size() const;
  void clear_ignore_object_ids();
  static const int kIgnoreObjectIdsFieldNumber = 5;
  const ::std::string& ignore_object_ids(int index) const;
  ::std::string* mutable_ignore_object_ids(int index);
  void set_ignore_object_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ignore_object_ids(int index, ::std::string&& value);
  #endif
  void set_ignore_object_ids(int index, const char* value);
  void set_ignore_object_ids(int index, const char* value, size_t size);
  ::std::string* add_ignore_object_ids();
  void add_ignore_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_ignore_object_ids(::std::string&& value);
  #endif
  void add_ignore_object_ids(const char* value);
  void add_ignore_object_ids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ignore_object_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ignore_object_ids();

  // optional string source_object_ids = 1;
  bool has_source_object_ids() const;
  void clear_source_object_ids();
  static const int kSourceObjectIdsFieldNumber = 1;
  const ::std::string& source_object_ids() const;
  void set_source_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void set_source_object_ids(::std::string&& value);
  #endif
  void set_source_object_ids(const char* value);
  void set_source_object_ids(const char* value, size_t size);
  ::std::string* mutable_source_object_ids();
  ::std::string* release_source_object_ids();
  void set_allocated_source_object_ids(::std::string* source_object_ids);

  // optional string target_object_ids = 2;
  bool has_target_object_ids() const;
  void clear_target_object_ids();
  static const int kTargetObjectIdsFieldNumber = 2;
  const ::std::string& target_object_ids() const;
  void set_target_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void set_target_object_ids(::std::string&& value);
  #endif
  void set_target_object_ids(const char* value);
  void set_target_object_ids(const char* value, size_t size);
  ::std::string* mutable_target_object_ids();
  ::std::string* release_target_object_ids();
  void set_allocated_target_object_ids(::std::string* target_object_ids);

  // optional double distance = 3;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  double distance() const;
  void set_distance(double value);

  // optional .apollo.simulation.ObjectOverlapCondition.DirectionType direction = 4 [default = EXCLUDE_BACK];
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 4;
  ::apollo::simulation::ObjectOverlapCondition_DirectionType direction() const;
  void set_direction(::apollo::simulation::ObjectOverlapCondition_DirectionType value);

  // optional bool use_score = 6 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 6;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.ObjectOverlapCondition)
 private:
  void set_has_source_object_ids();
  void clear_has_source_object_ids();
  void set_has_target_object_ids();
  void clear_has_target_object_ids();
  void set_has_distance();
  void clear_has_distance();
  void set_has_direction();
  void clear_has_direction();
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ignore_object_ids_;
  ::google::protobuf::internal::ArenaStringPtr source_object_ids_;
  ::google::protobuf::internal::ArenaStringPtr target_object_ids_;
  double distance_;
  int direction_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionOverlapCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RegionOverlapCondition) */ {
 public:
  RegionOverlapCondition();
  virtual ~RegionOverlapCondition();

  RegionOverlapCondition(const RegionOverlapCondition& from);

  inline RegionOverlapCondition& operator=(const RegionOverlapCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionOverlapCondition(RegionOverlapCondition&& from) noexcept
    : RegionOverlapCondition() {
    *this = ::std::move(from);
  }

  inline RegionOverlapCondition& operator=(RegionOverlapCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionOverlapCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionOverlapCondition* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapCondition*>(
               &_RegionOverlapCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(RegionOverlapCondition* other);
  friend void swap(RegionOverlapCondition& a, RegionOverlapCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionOverlapCondition* New() const final {
    return CreateMaybeMessage<RegionOverlapCondition>(NULL);
  }

  RegionOverlapCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegionOverlapCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegionOverlapCondition& from);
  void MergeFrom(const RegionOverlapCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOverlapCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double region_corner_xy = 2 [packed = true];
  int region_corner_xy_size() const;
  void clear_region_corner_xy();
  static const int kRegionCornerXyFieldNumber = 2;
  double region_corner_xy(int index) const;
  void set_region_corner_xy(int index, double value);
  void add_region_corner_xy(double value);
  const ::google::protobuf::RepeatedField< double >&
      region_corner_xy() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_region_corner_xy();

  // optional string object_ids = 1;
  bool has_object_ids() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 1;
  const ::std::string& object_ids() const;
  void set_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void set_object_ids(::std::string&& value);
  #endif
  void set_object_ids(const char* value);
  void set_object_ids(const char* value, size_t size);
  ::std::string* mutable_object_ids();
  ::std::string* release_object_ids();
  void set_allocated_object_ids(::std::string* object_ids);

  // optional double heading = 4;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 4;
  double heading() const;
  void set_heading(double value);

  // optional bool require_fully_contain = 3;
  bool has_require_fully_contain() const;
  void clear_require_fully_contain();
  static const int kRequireFullyContainFieldNumber = 3;
  bool require_fully_contain() const;
  void set_require_fully_contain(bool value);

  // optional bool use_score = 5 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 5;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.RegionOverlapCondition)
 private:
  void set_has_object_ids();
  void clear_has_object_ids();
  void set_has_require_fully_contain();
  void clear_has_require_fully_contain();
  void set_has_heading();
  void clear_has_heading();
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > region_corner_xy_;
  mutable int _region_corner_xy_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr object_ids_;
  double heading_;
  bool require_fully_contain_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionOverlapLWCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RegionOverlapLWCondition) */ {
 public:
  RegionOverlapLWCondition();
  virtual ~RegionOverlapLWCondition();

  RegionOverlapLWCondition(const RegionOverlapLWCondition& from);

  inline RegionOverlapLWCondition& operator=(const RegionOverlapLWCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionOverlapLWCondition(RegionOverlapLWCondition&& from) noexcept
    : RegionOverlapLWCondition() {
    *this = ::std::move(from);
  }

  inline RegionOverlapLWCondition& operator=(RegionOverlapLWCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionOverlapLWCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionOverlapLWCondition* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapLWCondition*>(
               &_RegionOverlapLWCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RegionOverlapLWCondition* other);
  friend void swap(RegionOverlapLWCondition& a, RegionOverlapLWCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionOverlapLWCondition* New() const final {
    return CreateMaybeMessage<RegionOverlapLWCondition>(NULL);
  }

  RegionOverlapLWCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegionOverlapLWCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegionOverlapLWCondition& from);
  void MergeFrom(const RegionOverlapLWCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOverlapLWCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string object_ids = 1;
  bool has_object_ids() const;
  void clear_object_ids();
  static const int kObjectIdsFieldNumber = 1;
  const ::std::string& object_ids() const;
  void set_object_ids(const ::std::string& value);
  #if LANG_CXX11
  void set_object_ids(::std::string&& value);
  #endif
  void set_object_ids(const char* value);
  void set_object_ids(const char* value, size_t size);
  ::std::string* mutable_object_ids();
  ::std::string* release_object_ids();
  void set_allocated_object_ids(::std::string* object_ids);

  // optional double x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // optional double y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // optional double length = 4;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  double length() const;
  void set_length(double value);

  // optional double width = 5;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 5;
  double width() const;
  void set_width(double value);

  // optional bool require_fully_contain = 6;
  bool has_require_fully_contain() const;
  void clear_require_fully_contain();
  static const int kRequireFullyContainFieldNumber = 6;
  bool require_fully_contain() const;
  void set_require_fully_contain(bool value);

  // optional bool use_score = 7 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 7;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.RegionOverlapLWCondition)
 private:
  void set_has_object_ids();
  void clear_has_object_ids();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_require_fully_contain();
  void clear_has_require_fully_contain();
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr object_ids_;
  double x_;
  double y_;
  double length_;
  double width_;
  bool require_fully_contain_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OnRoadCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.OnRoadCondition) */ {
 public:
  OnRoadCondition();
  virtual ~OnRoadCondition();

  OnRoadCondition(const OnRoadCondition& from);

  inline OnRoadCondition& operator=(const OnRoadCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnRoadCondition(OnRoadCondition&& from) noexcept
    : OnRoadCondition() {
    *this = ::std::move(from);
  }

  inline OnRoadCondition& operator=(OnRoadCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnRoadCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnRoadCondition* internal_default_instance() {
    return reinterpret_cast<const OnRoadCondition*>(
               &_OnRoadCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(OnRoadCondition* other);
  friend void swap(OnRoadCondition& a, OnRoadCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnRoadCondition* New() const final {
    return CreateMaybeMessage<OnRoadCondition>(NULL);
  }

  OnRoadCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OnRoadCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OnRoadCondition& from);
  void MergeFrom(const OnRoadCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnRoadCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_road_boundary = 1 [default = false];
  bool has_use_road_boundary() const;
  void clear_use_road_boundary();
  static const int kUseRoadBoundaryFieldNumber = 1;
  bool use_road_boundary() const;
  void set_use_road_boundary(bool value);

  // optional bool use_score = 2 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 2;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.OnRoadCondition)
 private:
  void set_has_use_road_boundary();
  void clear_has_use_road_boundary();
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_road_boundary_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RunRedLightCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RunRedLightCondition) */ {
 public:
  RunRedLightCondition();
  virtual ~RunRedLightCondition();

  RunRedLightCondition(const RunRedLightCondition& from);

  inline RunRedLightCondition& operator=(const RunRedLightCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunRedLightCondition(RunRedLightCondition&& from) noexcept
    : RunRedLightCondition() {
    *this = ::std::move(from);
  }

  inline RunRedLightCondition& operator=(RunRedLightCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunRedLightCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunRedLightCondition* internal_default_instance() {
    return reinterpret_cast<const RunRedLightCondition*>(
               &_RunRedLightCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RunRedLightCondition* other);
  friend void swap(RunRedLightCondition& a, RunRedLightCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunRedLightCondition* New() const final {
    return CreateMaybeMessage<RunRedLightCondition>(NULL);
  }

  RunRedLightCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunRedLightCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunRedLightCondition& from);
  void MergeFrom(const RunRedLightCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunRedLightCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_score = 1 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 1;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.RunRedLightCondition)
 private:
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedLightStopCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RedLightStopCondition) */ {
 public:
  RedLightStopCondition();
  virtual ~RedLightStopCondition();

  RedLightStopCondition(const RedLightStopCondition& from);

  inline RedLightStopCondition& operator=(const RedLightStopCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedLightStopCondition(RedLightStopCondition&& from) noexcept
    : RedLightStopCondition() {
    *this = ::std::move(from);
  }

  inline RedLightStopCondition& operator=(RedLightStopCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedLightStopCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RedLightStopCondition* internal_default_instance() {
    return reinterpret_cast<const RedLightStopCondition*>(
               &_RedLightStopCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RedLightStopCondition* other);
  friend void swap(RedLightStopCondition& a, RedLightStopCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedLightStopCondition* New() const final {
    return CreateMaybeMessage<RedLightStopCondition>(NULL);
  }

  RedLightStopCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RedLightStopCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RedLightStopCondition& from);
  void MergeFrom(const RedLightStopCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedLightStopCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_score = 3 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 3;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double min_distance = 1 [default = 2];
  bool has_min_distance() const;
  void clear_min_distance();
  static const int kMinDistanceFieldNumber = 1;
  double min_distance() const;
  void set_min_distance(double value);

  // optional double max_distance = 2 [default = 2.2];
  bool has_max_distance() const;
  void clear_max_distance();
  static const int kMaxDistanceFieldNumber = 2;
  double max_distance() const;
  void set_max_distance(double value);

  // optional double single_deduction = 4 [default = 5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 4;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.RedLightStopCondition)
 private:
  void set_has_min_distance();
  void clear_has_min_distance();
  void set_has_max_distance();
  void clear_has_max_distance();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_score_;
  double min_distance_;
  double max_distance_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangeLaneAtJunctionCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.ChangeLaneAtJunctionCondition) */ {
 public:
  ChangeLaneAtJunctionCondition();
  virtual ~ChangeLaneAtJunctionCondition();

  ChangeLaneAtJunctionCondition(const ChangeLaneAtJunctionCondition& from);

  inline ChangeLaneAtJunctionCondition& operator=(const ChangeLaneAtJunctionCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChangeLaneAtJunctionCondition(ChangeLaneAtJunctionCondition&& from) noexcept
    : ChangeLaneAtJunctionCondition() {
    *this = ::std::move(from);
  }

  inline ChangeLaneAtJunctionCondition& operator=(ChangeLaneAtJunctionCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeLaneAtJunctionCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeLaneAtJunctionCondition* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneAtJunctionCondition*>(
               &_ChangeLaneAtJunctionCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ChangeLaneAtJunctionCondition* other);
  friend void swap(ChangeLaneAtJunctionCondition& a, ChangeLaneAtJunctionCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangeLaneAtJunctionCondition* New() const final {
    return CreateMaybeMessage<ChangeLaneAtJunctionCondition>(NULL);
  }

  ChangeLaneAtJunctionCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChangeLaneAtJunctionCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChangeLaneAtJunctionCondition& from);
  void MergeFrom(const ChangeLaneAtJunctionCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneAtJunctionCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.ChangeLaneAtJunctionCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoutingCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RoutingCondition) */ {
 public:
  RoutingCondition();
  virtual ~RoutingCondition();

  RoutingCondition(const RoutingCondition& from);

  inline RoutingCondition& operator=(const RoutingCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingCondition(RoutingCondition&& from) noexcept
    : RoutingCondition() {
    *this = ::std::move(from);
  }

  inline RoutingCondition& operator=(RoutingCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingCondition* internal_default_instance() {
    return reinterpret_cast<const RoutingCondition*>(
               &_RoutingCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RoutingCondition* other);
  friend void swap(RoutingCondition& a, RoutingCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingCondition* New() const final {
    return CreateMaybeMessage<RoutingCondition>(NULL);
  }

  RoutingCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoutingCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoutingCondition& from);
  void MergeFrom(const RoutingCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.RoutingCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkYieldCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CrosswalkYieldCondition) */ {
 public:
  CrosswalkYieldCondition();
  virtual ~CrosswalkYieldCondition();

  CrosswalkYieldCondition(const CrosswalkYieldCondition& from);

  inline CrosswalkYieldCondition& operator=(const CrosswalkYieldCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrosswalkYieldCondition(CrosswalkYieldCondition&& from) noexcept
    : CrosswalkYieldCondition() {
    *this = ::std::move(from);
  }

  inline CrosswalkYieldCondition& operator=(CrosswalkYieldCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkYieldCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrosswalkYieldCondition* internal_default_instance() {
    return reinterpret_cast<const CrosswalkYieldCondition*>(
               &_CrosswalkYieldCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CrosswalkYieldCondition* other);
  friend void swap(CrosswalkYieldCondition& a, CrosswalkYieldCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkYieldCondition* New() const final {
    return CreateMaybeMessage<CrosswalkYieldCondition>(NULL);
  }

  CrosswalkYieldCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkYieldCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrosswalkYieldCondition& from);
  void MergeFrom(const CrosswalkYieldCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkYieldCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.CrosswalkYieldCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrosswalkStopCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CrosswalkStopCondition) */ {
 public:
  CrosswalkStopCondition();
  virtual ~CrosswalkStopCondition();

  CrosswalkStopCondition(const CrosswalkStopCondition& from);

  inline CrosswalkStopCondition& operator=(const CrosswalkStopCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrosswalkStopCondition(CrosswalkStopCondition&& from) noexcept
    : CrosswalkStopCondition() {
    *this = ::std::move(from);
  }

  inline CrosswalkStopCondition& operator=(CrosswalkStopCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkStopCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrosswalkStopCondition* internal_default_instance() {
    return reinterpret_cast<const CrosswalkStopCondition*>(
               &_CrosswalkStopCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CrosswalkStopCondition* other);
  friend void swap(CrosswalkStopCondition& a, CrosswalkStopCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkStopCondition* New() const final {
    return CreateMaybeMessage<CrosswalkStopCondition>(NULL);
  }

  CrosswalkStopCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkStopCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrosswalkStopCondition& from);
  void MergeFrom(const CrosswalkStopCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkStopCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_score = 3 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 3;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double min_distance = 1 [default = 2.2];
  bool has_min_distance() const;
  void clear_min_distance();
  static const int kMinDistanceFieldNumber = 1;
  double min_distance() const;
  void set_min_distance(double value);

  // optional double max_distance = 2 [default = 2.7];
  bool has_max_distance() const;
  void clear_max_distance();
  static const int kMaxDistanceFieldNumber = 2;
  double max_distance() const;
  void set_max_distance(double value);

  // optional double single_deduction = 4 [default = 5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 4;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.CrosswalkStopCondition)
 private:
  void set_has_min_distance();
  void clear_has_min_distance();
  void set_has_max_distance();
  void clear_has_max_distance();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_score_;
  double min_distance_;
  double max_distance_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AbnormalStopCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.AbnormalStopCondition) */ {
 public:
  AbnormalStopCondition();
  virtual ~AbnormalStopCondition();

  AbnormalStopCondition(const AbnormalStopCondition& from);

  inline AbnormalStopCondition& operator=(const AbnormalStopCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AbnormalStopCondition(AbnormalStopCondition&& from) noexcept
    : AbnormalStopCondition() {
    *this = ::std::move(from);
  }

  inline AbnormalStopCondition& operator=(AbnormalStopCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbnormalStopCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbnormalStopCondition* internal_default_instance() {
    return reinterpret_cast<const AbnormalStopCondition*>(
               &_AbnormalStopCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(AbnormalStopCondition* other);
  friend void swap(AbnormalStopCondition& a, AbnormalStopCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AbnormalStopCondition* New() const final {
    return CreateMaybeMessage<AbnormalStopCondition>(NULL);
  }

  AbnormalStopCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AbnormalStopCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AbnormalStopCondition& from);
  void MergeFrom(const AbnormalStopCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbnormalStopCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 3;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 3;
  double x() const;
  void set_x(double value);

  // optional double y = 4;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 4;
  double y() const;
  void set_y(double value);

  // optional double duration = 1 [default = 5];
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  double duration() const;
  void set_duration(double value);

  // optional double distance = 2 [default = 10];
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.AbnormalStopCondition)
 private:
  void set_has_duration();
  void clear_has_duration();
  void set_has_distance();
  void clear_has_distance();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double duration_;
  double distance_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BrakeTapCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.BrakeTapCondition) */ {
 public:
  BrakeTapCondition();
  virtual ~BrakeTapCondition();

  BrakeTapCondition(const BrakeTapCondition& from);

  inline BrakeTapCondition& operator=(const BrakeTapCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BrakeTapCondition(BrakeTapCondition&& from) noexcept
    : BrakeTapCondition() {
    *this = ::std::move(from);
  }

  inline BrakeTapCondition& operator=(BrakeTapCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrakeTapCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrakeTapCondition* internal_default_instance() {
    return reinterpret_cast<const BrakeTapCondition*>(
               &_BrakeTapCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(BrakeTapCondition* other);
  friend void swap(BrakeTapCondition& a, BrakeTapCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BrakeTapCondition* New() const final {
    return CreateMaybeMessage<BrakeTapCondition>(NULL);
  }

  BrakeTapCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BrakeTapCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BrakeTapCondition& from);
  void MergeFrom(const BrakeTapCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeTapCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double min_duration = 1 [default = 1];
  bool has_min_duration() const;
  void clear_min_duration();
  static const int kMinDurationFieldNumber = 1;
  double min_duration() const;
  void set_min_duration(double value);

  // optional double max_duration = 2 [default = 4];
  bool has_max_duration() const;
  void clear_max_duration();
  static const int kMaxDurationFieldNumber = 2;
  double max_duration() const;
  void set_max_duration(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.BrakeTapCondition)
 private:
  void set_has_min_duration();
  void clear_has_min_duration();
  void set_has_max_duration();
  void clear_has_max_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double min_duration_;
  double max_duration_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RunStopSignCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RunStopSignCondition) */ {
 public:
  RunStopSignCondition();
  virtual ~RunStopSignCondition();

  RunStopSignCondition(const RunStopSignCondition& from);

  inline RunStopSignCondition& operator=(const RunStopSignCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunStopSignCondition(RunStopSignCondition&& from) noexcept
    : RunStopSignCondition() {
    *this = ::std::move(from);
  }

  inline RunStopSignCondition& operator=(RunStopSignCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunStopSignCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunStopSignCondition* internal_default_instance() {
    return reinterpret_cast<const RunStopSignCondition*>(
               &_RunStopSignCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RunStopSignCondition* other);
  friend void swap(RunStopSignCondition& a, RunStopSignCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunStopSignCondition* New() const final {
    return CreateMaybeMessage<RunStopSignCondition>(NULL);
  }

  RunStopSignCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunStopSignCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunStopSignCondition& from);
  void MergeFrom(const RunStopSignCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunStopSignCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double distance = 1 [default = 2];
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 1;
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.RunStopSignCondition)
 private:
  void set_has_distance();
  void clear_has_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double distance_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckpointCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CheckpointCondition) */ {
 public:
  CheckpointCondition();
  virtual ~CheckpointCondition();

  CheckpointCondition(const CheckpointCondition& from);

  inline CheckpointCondition& operator=(const CheckpointCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CheckpointCondition(CheckpointCondition&& from) noexcept
    : CheckpointCondition() {
    *this = ::std::move(from);
  }

  inline CheckpointCondition& operator=(CheckpointCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckpointCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckpointCondition* internal_default_instance() {
    return reinterpret_cast<const CheckpointCondition*>(
               &_CheckpointCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CheckpointCondition* other);
  friend void swap(CheckpointCondition& a, CheckpointCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckpointCondition* New() const final {
    return CreateMaybeMessage<CheckpointCondition>(NULL);
  }

  CheckpointCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CheckpointCondition& from);
  void MergeFrom(const CheckpointCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.simulation.Condition checkpoint = 1;
  int checkpoint_size() const;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 1;
  ::apollo::simulation::Condition* mutable_checkpoint(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >*
      mutable_checkpoint();
  const ::apollo::simulation::Condition& checkpoint(int index) const;
  ::apollo::simulation::Condition* add_checkpoint();
  const ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >&
      checkpoint() const;

  // @@protoc_insertion_point(class_scope:apollo.simulation.CheckpointCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition > checkpoint_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DistToEndCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.DistToEndCondition) */ {
 public:
  DistToEndCondition();
  virtual ~DistToEndCondition();

  DistToEndCondition(const DistToEndCondition& from);

  inline DistToEndCondition& operator=(const DistToEndCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DistToEndCondition(DistToEndCondition&& from) noexcept
    : DistToEndCondition() {
    *this = ::std::move(from);
  }

  inline DistToEndCondition& operator=(DistToEndCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistToEndCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistToEndCondition* internal_default_instance() {
    return reinterpret_cast<const DistToEndCondition*>(
               &_DistToEndCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(DistToEndCondition* other);
  friend void swap(DistToEndCondition& a, DistToEndCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistToEndCondition* New() const final {
    return CreateMaybeMessage<DistToEndCondition>(NULL);
  }

  DistToEndCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DistToEndCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DistToEndCondition& from);
  void MergeFrom(const DistToEndCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistToEndCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.DistToEndCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DistToLaneCenterCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.DistToLaneCenterCondition) */ {
 public:
  DistToLaneCenterCondition();
  virtual ~DistToLaneCenterCondition();

  DistToLaneCenterCondition(const DistToLaneCenterCondition& from);

  inline DistToLaneCenterCondition& operator=(const DistToLaneCenterCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DistToLaneCenterCondition(DistToLaneCenterCondition&& from) noexcept
    : DistToLaneCenterCondition() {
    *this = ::std::move(from);
  }

  inline DistToLaneCenterCondition& operator=(DistToLaneCenterCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DistToLaneCenterCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistToLaneCenterCondition* internal_default_instance() {
    return reinterpret_cast<const DistToLaneCenterCondition*>(
               &_DistToLaneCenterCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(DistToLaneCenterCondition* other);
  friend void swap(DistToLaneCenterCondition& a, DistToLaneCenterCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistToLaneCenterCondition* New() const final {
    return CreateMaybeMessage<DistToLaneCenterCondition>(NULL);
  }

  DistToLaneCenterCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DistToLaneCenterCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DistToLaneCenterCondition& from);
  void MergeFrom(const DistToLaneCenterCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistToLaneCenterCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.DistToLaneCenterCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimeLimitCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.TimeLimitCondition) */ {
 public:
  TimeLimitCondition();
  virtual ~TimeLimitCondition();

  TimeLimitCondition(const TimeLimitCondition& from);

  inline TimeLimitCondition& operator=(const TimeLimitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeLimitCondition(TimeLimitCondition&& from) noexcept
    : TimeLimitCondition() {
    *this = ::std::move(from);
  }

  inline TimeLimitCondition& operator=(TimeLimitCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeLimitCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeLimitCondition* internal_default_instance() {
    return reinterpret_cast<const TimeLimitCondition*>(
               &_TimeLimitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(TimeLimitCondition* other);
  friend void swap(TimeLimitCondition& a, TimeLimitCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeLimitCondition* New() const final {
    return CreateMaybeMessage<TimeLimitCondition>(NULL);
  }

  TimeLimitCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimeLimitCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimeLimitCondition& from);
  void MergeFrom(const TimeLimitCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeLimitCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timeout = 1;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  double timeout() const;
  void set_timeout(double value);

  // optional bool use_score = 2 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 2;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.TimeLimitCondition)
 private:
  void set_has_timeout();
  void clear_has_timeout();
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double timeout_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedbumpLimitCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.SpeedbumpLimitCondition) */ {
 public:
  SpeedbumpLimitCondition();
  virtual ~SpeedbumpLimitCondition();

  SpeedbumpLimitCondition(const SpeedbumpLimitCondition& from);

  inline SpeedbumpLimitCondition& operator=(const SpeedbumpLimitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedbumpLimitCondition(SpeedbumpLimitCondition&& from) noexcept
    : SpeedbumpLimitCondition() {
    *this = ::std::move(from);
  }

  inline SpeedbumpLimitCondition& operator=(SpeedbumpLimitCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedbumpLimitCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedbumpLimitCondition* internal_default_instance() {
    return reinterpret_cast<const SpeedbumpLimitCondition*>(
               &_SpeedbumpLimitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(SpeedbumpLimitCondition* other);
  friend void swap(SpeedbumpLimitCondition& a, SpeedbumpLimitCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedbumpLimitCondition* New() const final {
    return CreateMaybeMessage<SpeedbumpLimitCondition>(NULL);
  }

  SpeedbumpLimitCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeedbumpLimitCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeedbumpLimitCondition& from);
  void MergeFrom(const SpeedbumpLimitCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedbumpLimitCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 4;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double speedbump_half_width = 1 [default = 0.2];
  bool has_speedbump_half_width() const;
  void clear_speedbump_half_width();
  static const int kSpeedbumpHalfWidthFieldNumber = 1;
  double speedbump_half_width() const;
  void set_speedbump_half_width(double value);

  // optional double max_speed = 2 [default = 3];
  bool has_max_speed() const;
  void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 2;
  double max_speed() const;
  void set_max_speed(double value);

  // optional double deduction_speed_unit = 3 [default = 1];
  bool has_deduction_speed_unit() const;
  void clear_deduction_speed_unit();
  static const int kDeductionSpeedUnitFieldNumber = 3;
  double deduction_speed_unit() const;
  void set_deduction_speed_unit(double value);

  // optional double single_deduction = 5 [default = 5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 5;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.SpeedbumpLimitCondition)
 private:
  void set_has_speedbump_half_width();
  void clear_has_speedbump_half_width();
  void set_has_max_speed();
  void clear_has_max_speed();
  void set_has_deduction_speed_unit();
  void clear_has_deduction_speed_unit();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_score_;
  double speedbump_half_width_;
  double max_speed_;
  double deduction_speed_unit_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkingZoneAvoidLimitCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.WorkingZoneAvoidLimitCondition) */ {
 public:
  WorkingZoneAvoidLimitCondition();
  virtual ~WorkingZoneAvoidLimitCondition();

  WorkingZoneAvoidLimitCondition(const WorkingZoneAvoidLimitCondition& from);

  inline WorkingZoneAvoidLimitCondition& operator=(const WorkingZoneAvoidLimitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkingZoneAvoidLimitCondition(WorkingZoneAvoidLimitCondition&& from) noexcept
    : WorkingZoneAvoidLimitCondition() {
    *this = ::std::move(from);
  }

  inline WorkingZoneAvoidLimitCondition& operator=(WorkingZoneAvoidLimitCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkingZoneAvoidLimitCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkingZoneAvoidLimitCondition* internal_default_instance() {
    return reinterpret_cast<const WorkingZoneAvoidLimitCondition*>(
               &_WorkingZoneAvoidLimitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(WorkingZoneAvoidLimitCondition* other);
  friend void swap(WorkingZoneAvoidLimitCondition& a, WorkingZoneAvoidLimitCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkingZoneAvoidLimitCondition* New() const final {
    return CreateMaybeMessage<WorkingZoneAvoidLimitCondition>(NULL);
  }

  WorkingZoneAvoidLimitCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkingZoneAvoidLimitCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkingZoneAvoidLimitCondition& from);
  void MergeFrom(const WorkingZoneAvoidLimitCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkingZoneAvoidLimitCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.hdmap.Polygon working_zone = 1;
  int working_zone_size() const;
  void clear_working_zone();
  static const int kWorkingZoneFieldNumber = 1;
  ::apollo::hdmap::Polygon* mutable_working_zone(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >*
      mutable_working_zone();
  const ::apollo::hdmap::Polygon& working_zone(int index) const;
  ::apollo::hdmap::Polygon* add_working_zone();
  const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >&
      working_zone() const;

  // optional .apollo.hdmap.Polygon whole_area = 3;
  bool has_whole_area() const;
  void clear_whole_area();
  static const int kWholeAreaFieldNumber = 3;
  private:
  const ::apollo::hdmap::Polygon& _internal_whole_area() const;
  public:
  const ::apollo::hdmap::Polygon& whole_area() const;
  ::apollo::hdmap::Polygon* release_whole_area();
  ::apollo::hdmap::Polygon* mutable_whole_area();
  void set_allocated_whole_area(::apollo::hdmap::Polygon* whole_area);

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 4;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double max_speed = 2 [default = 8.33];
  bool has_max_speed() const;
  void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 2;
  double max_speed() const;
  void set_max_speed(double value);

  // optional double single_deduction = 5 [default = 3];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 5;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.WorkingZoneAvoidLimitCondition)
 private:
  void set_has_max_speed();
  void clear_has_max_speed();
  void set_has_whole_area();
  void clear_has_whole_area();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon > working_zone_;
  ::apollo::hdmap::Polygon* whole_area_;
  bool use_score_;
  double max_speed_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LimitedTimeParkingCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.LimitedTimeParkingCondition) */ {
 public:
  LimitedTimeParkingCondition();
  virtual ~LimitedTimeParkingCondition();

  LimitedTimeParkingCondition(const LimitedTimeParkingCondition& from);

  inline LimitedTimeParkingCondition& operator=(const LimitedTimeParkingCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LimitedTimeParkingCondition(LimitedTimeParkingCondition&& from) noexcept
    : LimitedTimeParkingCondition() {
    *this = ::std::move(from);
  }

  inline LimitedTimeParkingCondition& operator=(LimitedTimeParkingCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LimitedTimeParkingCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LimitedTimeParkingCondition* internal_default_instance() {
    return reinterpret_cast<const LimitedTimeParkingCondition*>(
               &_LimitedTimeParkingCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(LimitedTimeParkingCondition* other);
  friend void swap(LimitedTimeParkingCondition& a, LimitedTimeParkingCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LimitedTimeParkingCondition* New() const final {
    return CreateMaybeMessage<LimitedTimeParkingCondition>(NULL);
  }

  LimitedTimeParkingCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LimitedTimeParkingCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LimitedTimeParkingCondition& from);
  void MergeFrom(const LimitedTimeParkingCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitedTimeParkingCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.hdmap.Polygon parking_lot = 1;
  bool has_parking_lot() const;
  void clear_parking_lot();
  static const int kParkingLotFieldNumber = 1;
  private:
  const ::apollo::hdmap::Polygon& _internal_parking_lot() const;
  public:
  const ::apollo::hdmap::Polygon& parking_lot() const;
  ::apollo::hdmap::Polygon* release_parking_lot();
  ::apollo::hdmap::Polygon* mutable_parking_lot();
  void set_allocated_parking_lot(::apollo::hdmap::Polygon* parking_lot);

  // optional bool use_score = 2 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 2;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double single_deduction = 3 [default = 5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 3;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.LimitedTimeParkingCondition)
 private:
  void set_has_parking_lot();
  void clear_has_parking_lot();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::hdmap::Polygon* parking_lot_;
  bool use_score_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FollowAndBypassCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.FollowAndBypassCondition) */ {
 public:
  FollowAndBypassCondition();
  virtual ~FollowAndBypassCondition();

  FollowAndBypassCondition(const FollowAndBypassCondition& from);

  inline FollowAndBypassCondition& operator=(const FollowAndBypassCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowAndBypassCondition(FollowAndBypassCondition&& from) noexcept
    : FollowAndBypassCondition() {
    *this = ::std::move(from);
  }

  inline FollowAndBypassCondition& operator=(FollowAndBypassCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowAndBypassCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowAndBypassCondition* internal_default_instance() {
    return reinterpret_cast<const FollowAndBypassCondition*>(
               &_FollowAndBypassCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(FollowAndBypassCondition* other);
  friend void swap(FollowAndBypassCondition& a, FollowAndBypassCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowAndBypassCondition* New() const final {
    return CreateMaybeMessage<FollowAndBypassCondition>(NULL);
  }

  FollowAndBypassCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FollowAndBypassCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FollowAndBypassCondition& from);
  void MergeFrom(const FollowAndBypassCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowAndBypassCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string obstacle_id = 3;
  bool has_obstacle_id() const;
  void clear_obstacle_id();
  static const int kObstacleIdFieldNumber = 3;
  const ::std::string& obstacle_id() const;
  void set_obstacle_id(const ::std::string& value);
  #if LANG_CXX11
  void set_obstacle_id(::std::string&& value);
  #endif
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  ::std::string* mutable_obstacle_id();
  ::std::string* release_obstacle_id();
  void set_allocated_obstacle_id(::std::string* obstacle_id);

  // optional .apollo.hdmap.Polygon test_range = 1;
  bool has_test_range() const;
  void clear_test_range();
  static const int kTestRangeFieldNumber = 1;
  private:
  const ::apollo::hdmap::Polygon& _internal_test_range() const;
  public:
  const ::apollo::hdmap::Polygon& test_range() const;
  ::apollo::hdmap::Polygon* release_test_range();
  ::apollo::hdmap::Polygon* mutable_test_range();
  void set_allocated_test_range(::apollo::hdmap::Polygon* test_range);

  // optional .apollo.hdmap.LineSegment end_line = 4;
  bool has_end_line() const;
  void clear_end_line();
  static const int kEndLineFieldNumber = 4;
  private:
  const ::apollo::hdmap::LineSegment& _internal_end_line() const;
  public:
  const ::apollo::hdmap::LineSegment& end_line() const;
  ::apollo::hdmap::LineSegment* release_end_line();
  ::apollo::hdmap::LineSegment* mutable_end_line();
  void set_allocated_end_line(::apollo::hdmap::LineSegment* end_line);

  // optional bool use_score = 5 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 5;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double divide_speed = 2 [default = 3];
  bool has_divide_speed() const;
  void clear_divide_speed();
  static const int kDivideSpeedFieldNumber = 2;
  double divide_speed() const;
  void set_divide_speed(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.FollowAndBypassCondition)
 private:
  void set_has_test_range();
  void clear_has_test_range();
  void set_has_divide_speed();
  void clear_has_divide_speed();
  void set_has_obstacle_id();
  void clear_has_obstacle_id();
  void set_has_end_line();
  void clear_has_end_line();
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr obstacle_id_;
  ::apollo::hdmap::Polygon* test_range_;
  ::apollo::hdmap::LineSegment* end_line_;
  bool use_score_;
  double divide_speed_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleBypassCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.ObstacleBypassCondition) */ {
 public:
  ObstacleBypassCondition();
  virtual ~ObstacleBypassCondition();

  ObstacleBypassCondition(const ObstacleBypassCondition& from);

  inline ObstacleBypassCondition& operator=(const ObstacleBypassCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleBypassCondition(ObstacleBypassCondition&& from) noexcept
    : ObstacleBypassCondition() {
    *this = ::std::move(from);
  }

  inline ObstacleBypassCondition& operator=(ObstacleBypassCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleBypassCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleBypassCondition* internal_default_instance() {
    return reinterpret_cast<const ObstacleBypassCondition*>(
               &_ObstacleBypassCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ObstacleBypassCondition* other);
  friend void swap(ObstacleBypassCondition& a, ObstacleBypassCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleBypassCondition* New() const final {
    return CreateMaybeMessage<ObstacleBypassCondition>(NULL);
  }

  ObstacleBypassCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleBypassCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObstacleBypassCondition& from);
  void MergeFrom(const ObstacleBypassCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleBypassCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string obstacle_id = 2;
  bool has_obstacle_id() const;
  void clear_obstacle_id();
  static const int kObstacleIdFieldNumber = 2;
  const ::std::string& obstacle_id() const;
  void set_obstacle_id(const ::std::string& value);
  #if LANG_CXX11
  void set_obstacle_id(::std::string&& value);
  #endif
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  ::std::string* mutable_obstacle_id();
  ::std::string* release_obstacle_id();
  void set_allocated_obstacle_id(::std::string* obstacle_id);

  // optional .apollo.hdmap.Polygon test_range = 1;
  bool has_test_range() const;
  void clear_test_range();
  static const int kTestRangeFieldNumber = 1;
  private:
  const ::apollo::hdmap::Polygon& _internal_test_range() const;
  public:
  const ::apollo::hdmap::Polygon& test_range() const;
  ::apollo::hdmap::Polygon* release_test_range();
  ::apollo::hdmap::Polygon* mutable_test_range();
  void set_allocated_test_range(::apollo::hdmap::Polygon* test_range);

  // optional bool use_score = 5 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 5;
  bool use_score() const;
  void set_use_score(bool value);

  // optional double min_lateral_distance = 3 [default = 1];
  bool has_min_lateral_distance() const;
  void clear_min_lateral_distance();
  static const int kMinLateralDistanceFieldNumber = 3;
  double min_lateral_distance() const;
  void set_min_lateral_distance(double value);

  // optional double max_speed = 4 [default = 5];
  bool has_max_speed() const;
  void clear_max_speed();
  static const int kMaxSpeedFieldNumber = 4;
  double max_speed() const;
  void set_max_speed(double value);

  // optional double single_deduction = 6 [default = 5];
  bool has_single_deduction() const;
  void clear_single_deduction();
  static const int kSingleDeductionFieldNumber = 6;
  double single_deduction() const;
  void set_single_deduction(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.ObstacleBypassCondition)
 private:
  void set_has_test_range();
  void clear_has_test_range();
  void set_has_obstacle_id();
  void clear_has_obstacle_id();
  void set_has_min_lateral_distance();
  void clear_has_min_lateral_distance();
  void set_has_max_speed();
  void clear_has_max_speed();
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_single_deduction();
  void clear_has_single_deduction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr obstacle_id_;
  ::apollo::hdmap::Polygon* test_range_;
  bool use_score_;
  double min_lateral_distance_;
  double max_speed_;
  double single_deduction_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AntiCheatingCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.AntiCheatingCondition) */ {
 public:
  AntiCheatingCondition();
  virtual ~AntiCheatingCondition();

  AntiCheatingCondition(const AntiCheatingCondition& from);

  inline AntiCheatingCondition& operator=(const AntiCheatingCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AntiCheatingCondition(AntiCheatingCondition&& from) noexcept
    : AntiCheatingCondition() {
    *this = ::std::move(from);
  }

  inline AntiCheatingCondition& operator=(AntiCheatingCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AntiCheatingCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AntiCheatingCondition* internal_default_instance() {
    return reinterpret_cast<const AntiCheatingCondition*>(
               &_AntiCheatingCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(AntiCheatingCondition* other);
  friend void swap(AntiCheatingCondition& a, AntiCheatingCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AntiCheatingCondition* New() const final {
    return CreateMaybeMessage<AntiCheatingCondition>(NULL);
  }

  AntiCheatingCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AntiCheatingCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AntiCheatingCondition& from);
  void MergeFrom(const AntiCheatingCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntiCheatingCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_score = 1 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 1;
  bool use_score() const;
  void set_use_score(bool value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.AntiCheatingCondition)
 private:
  void set_has_use_score();
  void clear_has_use_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_score_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.KeyPoint) */ {
 public:
  KeyPoint();
  virtual ~KeyPoint();

  KeyPoint(const KeyPoint& from);

  inline KeyPoint& operator=(const KeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyPoint(KeyPoint&& from) noexcept
    : KeyPoint() {
    *this = ::std::move(from);
  }

  inline KeyPoint& operator=(KeyPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyPoint* internal_default_instance() {
    return reinterpret_cast<const KeyPoint*>(
               &_KeyPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(KeyPoint* other);
  friend void swap(KeyPoint& a, KeyPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyPoint* New() const final {
    return CreateMaybeMessage<KeyPoint>(NULL);
  }

  KeyPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyPoint& from);
  void MergeFrom(const KeyPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double radius = 4 [default = 2];
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 4;
  double radius() const;
  void set_radius(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.KeyPoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_radius();
  void clear_has_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double radius_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyPointCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.KeyPointCondition) */ {
 public:
  KeyPointCondition();
  virtual ~KeyPointCondition();

  KeyPointCondition(const KeyPointCondition& from);

  inline KeyPointCondition& operator=(const KeyPointCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyPointCondition(KeyPointCondition&& from) noexcept
    : KeyPointCondition() {
    *this = ::std::move(from);
  }

  inline KeyPointCondition& operator=(KeyPointCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyPointCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyPointCondition* internal_default_instance() {
    return reinterpret_cast<const KeyPointCondition*>(
               &_KeyPointCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(KeyPointCondition* other);
  friend void swap(KeyPointCondition& a, KeyPointCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyPointCondition* New() const final {
    return CreateMaybeMessage<KeyPointCondition>(NULL);
  }

  KeyPointCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyPointCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyPointCondition& from);
  void MergeFrom(const KeyPointCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyPointCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.simulation.KeyPoint point = 4;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 4;
  ::apollo::simulation::KeyPoint* mutable_point(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::simulation::KeyPoint >*
      mutable_point();
  const ::apollo::simulation::KeyPoint& point(int index) const;
  ::apollo::simulation::KeyPoint* add_point();
  const ::google::protobuf::RepeatedPtrField< ::apollo::simulation::KeyPoint >&
      point() const;

  // optional bool use_score = 1 [default = false];
  bool has_use_score() const;
  void clear_use_score();
  static const int kUseScoreFieldNumber = 1;
  bool use_score() const;
  void set_use_score(bool value);

  // optional bool in_order = 2 [default = true];
  bool has_in_order() const;
  void clear_in_order();
  static const int kInOrderFieldNumber = 2;
  bool in_order() const;
  void set_in_order(bool value);

  // optional double radius = 3 [default = 2];
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 3;
  double radius() const;
  void set_radius(double value);

  // @@protoc_insertion_point(class_scope:apollo.simulation.KeyPointCondition)
 private:
  void set_has_use_score();
  void clear_has_use_score();
  void set_has_in_order();
  void clear_has_in_order();
  void set_has_radius();
  void clear_has_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::simulation::KeyPoint > point_;
  bool use_score_;
  bool in_order_;
  double radius_;
  friend struct ::protobuf_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Condition

// optional .apollo.simulation.LogicalCondition logical_condition = 1;
inline bool Condition::has_logical_condition() const {
  return condition_case() == kLogicalCondition;
}
inline void Condition::set_has_logical_condition() {
  _oneof_case_[0] = kLogicalCondition;
}
inline void Condition::clear_logical_condition() {
  if (has_logical_condition()) {
    delete condition_.logical_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::LogicalCondition& Condition::_internal_logical_condition() const {
  return *condition_.logical_condition_;
}
inline ::apollo::simulation::LogicalCondition* Condition::release_logical_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.logical_condition)
  if (has_logical_condition()) {
    clear_has_condition();
      ::apollo::simulation::LogicalCondition* temp = condition_.logical_condition_;
    condition_.logical_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::LogicalCondition& Condition::logical_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.logical_condition)
  return has_logical_condition()
      ? *condition_.logical_condition_
      : *reinterpret_cast< ::apollo::simulation::LogicalCondition*>(&::apollo::simulation::_LogicalCondition_default_instance_);
}
inline ::apollo::simulation::LogicalCondition* Condition::mutable_logical_condition() {
  if (!has_logical_condition()) {
    clear_condition();
    set_has_logical_condition();
    condition_.logical_condition_ = CreateMaybeMessage< ::apollo::simulation::LogicalCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.logical_condition)
  return condition_.logical_condition_;
}

// optional .apollo.simulation.SpeedCondition speed_condition = 2;
inline bool Condition::has_speed_condition() const {
  return condition_case() == kSpeedCondition;
}
inline void Condition::set_has_speed_condition() {
  _oneof_case_[0] = kSpeedCondition;
}
inline void Condition::clear_speed_condition() {
  if (has_speed_condition()) {
    delete condition_.speed_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::SpeedCondition& Condition::_internal_speed_condition() const {
  return *condition_.speed_condition_;
}
inline ::apollo::simulation::SpeedCondition* Condition::release_speed_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.speed_condition)
  if (has_speed_condition()) {
    clear_has_condition();
      ::apollo::simulation::SpeedCondition* temp = condition_.speed_condition_;
    condition_.speed_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::SpeedCondition& Condition::speed_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.speed_condition)
  return has_speed_condition()
      ? *condition_.speed_condition_
      : *reinterpret_cast< ::apollo::simulation::SpeedCondition*>(&::apollo::simulation::_SpeedCondition_default_instance_);
}
inline ::apollo::simulation::SpeedCondition* Condition::mutable_speed_condition() {
  if (!has_speed_condition()) {
    clear_condition();
    set_has_speed_condition();
    condition_.speed_condition_ = CreateMaybeMessage< ::apollo::simulation::SpeedCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.speed_condition)
  return condition_.speed_condition_;
}

// optional .apollo.simulation.AccelerationCondition acceleration_condition = 3;
inline bool Condition::has_acceleration_condition() const {
  return condition_case() == kAccelerationCondition;
}
inline void Condition::set_has_acceleration_condition() {
  _oneof_case_[0] = kAccelerationCondition;
}
inline void Condition::clear_acceleration_condition() {
  if (has_acceleration_condition()) {
    delete condition_.acceleration_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::AccelerationCondition& Condition::_internal_acceleration_condition() const {
  return *condition_.acceleration_condition_;
}
inline ::apollo::simulation::AccelerationCondition* Condition::release_acceleration_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.acceleration_condition)
  if (has_acceleration_condition()) {
    clear_has_condition();
      ::apollo::simulation::AccelerationCondition* temp = condition_.acceleration_condition_;
    condition_.acceleration_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::AccelerationCondition& Condition::acceleration_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.acceleration_condition)
  return has_acceleration_condition()
      ? *condition_.acceleration_condition_
      : *reinterpret_cast< ::apollo::simulation::AccelerationCondition*>(&::apollo::simulation::_AccelerationCondition_default_instance_);
}
inline ::apollo::simulation::AccelerationCondition* Condition::mutable_acceleration_condition() {
  if (!has_acceleration_condition()) {
    clear_condition();
    set_has_acceleration_condition();
    condition_.acceleration_condition_ = CreateMaybeMessage< ::apollo::simulation::AccelerationCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.acceleration_condition)
  return condition_.acceleration_condition_;
}

// optional .apollo.simulation.JerkCondition jerk_condition = 4;
inline bool Condition::has_jerk_condition() const {
  return condition_case() == kJerkCondition;
}
inline void Condition::set_has_jerk_condition() {
  _oneof_case_[0] = kJerkCondition;
}
inline void Condition::clear_jerk_condition() {
  if (has_jerk_condition()) {
    delete condition_.jerk_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::JerkCondition& Condition::_internal_jerk_condition() const {
  return *condition_.jerk_condition_;
}
inline ::apollo::simulation::JerkCondition* Condition::release_jerk_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.jerk_condition)
  if (has_jerk_condition()) {
    clear_has_condition();
      ::apollo::simulation::JerkCondition* temp = condition_.jerk_condition_;
    condition_.jerk_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::JerkCondition& Condition::jerk_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.jerk_condition)
  return has_jerk_condition()
      ? *condition_.jerk_condition_
      : *reinterpret_cast< ::apollo::simulation::JerkCondition*>(&::apollo::simulation::_JerkCondition_default_instance_);
}
inline ::apollo::simulation::JerkCondition* Condition::mutable_jerk_condition() {
  if (!has_jerk_condition()) {
    clear_condition();
    set_has_jerk_condition();
    condition_.jerk_condition_ = CreateMaybeMessage< ::apollo::simulation::JerkCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.jerk_condition)
  return condition_.jerk_condition_;
}

// optional .apollo.simulation.ObjectOverlapCondition object_overlap_condition = 5;
inline bool Condition::has_object_overlap_condition() const {
  return condition_case() == kObjectOverlapCondition;
}
inline void Condition::set_has_object_overlap_condition() {
  _oneof_case_[0] = kObjectOverlapCondition;
}
inline void Condition::clear_object_overlap_condition() {
  if (has_object_overlap_condition()) {
    delete condition_.object_overlap_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::ObjectOverlapCondition& Condition::_internal_object_overlap_condition() const {
  return *condition_.object_overlap_condition_;
}
inline ::apollo::simulation::ObjectOverlapCondition* Condition::release_object_overlap_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.object_overlap_condition)
  if (has_object_overlap_condition()) {
    clear_has_condition();
      ::apollo::simulation::ObjectOverlapCondition* temp = condition_.object_overlap_condition_;
    condition_.object_overlap_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::ObjectOverlapCondition& Condition::object_overlap_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.object_overlap_condition)
  return has_object_overlap_condition()
      ? *condition_.object_overlap_condition_
      : *reinterpret_cast< ::apollo::simulation::ObjectOverlapCondition*>(&::apollo::simulation::_ObjectOverlapCondition_default_instance_);
}
inline ::apollo::simulation::ObjectOverlapCondition* Condition::mutable_object_overlap_condition() {
  if (!has_object_overlap_condition()) {
    clear_condition();
    set_has_object_overlap_condition();
    condition_.object_overlap_condition_ = CreateMaybeMessage< ::apollo::simulation::ObjectOverlapCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.object_overlap_condition)
  return condition_.object_overlap_condition_;
}

// optional .apollo.simulation.RegionOverlapCondition region_overlap_condition = 6;
inline bool Condition::has_region_overlap_condition() const {
  return condition_case() == kRegionOverlapCondition;
}
inline void Condition::set_has_region_overlap_condition() {
  _oneof_case_[0] = kRegionOverlapCondition;
}
inline void Condition::clear_region_overlap_condition() {
  if (has_region_overlap_condition()) {
    delete condition_.region_overlap_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::RegionOverlapCondition& Condition::_internal_region_overlap_condition() const {
  return *condition_.region_overlap_condition_;
}
inline ::apollo::simulation::RegionOverlapCondition* Condition::release_region_overlap_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.region_overlap_condition)
  if (has_region_overlap_condition()) {
    clear_has_condition();
      ::apollo::simulation::RegionOverlapCondition* temp = condition_.region_overlap_condition_;
    condition_.region_overlap_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::RegionOverlapCondition& Condition::region_overlap_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.region_overlap_condition)
  return has_region_overlap_condition()
      ? *condition_.region_overlap_condition_
      : *reinterpret_cast< ::apollo::simulation::RegionOverlapCondition*>(&::apollo::simulation::_RegionOverlapCondition_default_instance_);
}
inline ::apollo::simulation::RegionOverlapCondition* Condition::mutable_region_overlap_condition() {
  if (!has_region_overlap_condition()) {
    clear_condition();
    set_has_region_overlap_condition();
    condition_.region_overlap_condition_ = CreateMaybeMessage< ::apollo::simulation::RegionOverlapCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.region_overlap_condition)
  return condition_.region_overlap_condition_;
}

// optional .apollo.simulation.RegionOverlapLWCondition region_overlap_lw_condition = 7;
inline bool Condition::has_region_overlap_lw_condition() const {
  return condition_case() == kRegionOverlapLwCondition;
}
inline void Condition::set_has_region_overlap_lw_condition() {
  _oneof_case_[0] = kRegionOverlapLwCondition;
}
inline void Condition::clear_region_overlap_lw_condition() {
  if (has_region_overlap_lw_condition()) {
    delete condition_.region_overlap_lw_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::RegionOverlapLWCondition& Condition::_internal_region_overlap_lw_condition() const {
  return *condition_.region_overlap_lw_condition_;
}
inline ::apollo::simulation::RegionOverlapLWCondition* Condition::release_region_overlap_lw_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.region_overlap_lw_condition)
  if (has_region_overlap_lw_condition()) {
    clear_has_condition();
      ::apollo::simulation::RegionOverlapLWCondition* temp = condition_.region_overlap_lw_condition_;
    condition_.region_overlap_lw_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::RegionOverlapLWCondition& Condition::region_overlap_lw_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.region_overlap_lw_condition)
  return has_region_overlap_lw_condition()
      ? *condition_.region_overlap_lw_condition_
      : *reinterpret_cast< ::apollo::simulation::RegionOverlapLWCondition*>(&::apollo::simulation::_RegionOverlapLWCondition_default_instance_);
}
inline ::apollo::simulation::RegionOverlapLWCondition* Condition::mutable_region_overlap_lw_condition() {
  if (!has_region_overlap_lw_condition()) {
    clear_condition();
    set_has_region_overlap_lw_condition();
    condition_.region_overlap_lw_condition_ = CreateMaybeMessage< ::apollo::simulation::RegionOverlapLWCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.region_overlap_lw_condition)
  return condition_.region_overlap_lw_condition_;
}

// optional .apollo.simulation.SpinCondition spin_condition = 8;
inline bool Condition::has_spin_condition() const {
  return condition_case() == kSpinCondition;
}
inline void Condition::set_has_spin_condition() {
  _oneof_case_[0] = kSpinCondition;
}
inline void Condition::clear_spin_condition() {
  if (has_spin_condition()) {
    delete condition_.spin_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::SpinCondition& Condition::_internal_spin_condition() const {
  return *condition_.spin_condition_;
}
inline ::apollo::simulation::SpinCondition* Condition::release_spin_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.spin_condition)
  if (has_spin_condition()) {
    clear_has_condition();
      ::apollo::simulation::SpinCondition* temp = condition_.spin_condition_;
    condition_.spin_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::SpinCondition& Condition::spin_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.spin_condition)
  return has_spin_condition()
      ? *condition_.spin_condition_
      : *reinterpret_cast< ::apollo::simulation::SpinCondition*>(&::apollo::simulation::_SpinCondition_default_instance_);
}
inline ::apollo::simulation::SpinCondition* Condition::mutable_spin_condition() {
  if (!has_spin_condition()) {
    clear_condition();
    set_has_spin_condition();
    condition_.spin_condition_ = CreateMaybeMessage< ::apollo::simulation::SpinCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.spin_condition)
  return condition_.spin_condition_;
}

// optional .apollo.simulation.OnRoadCondition on_road_condition = 9;
inline bool Condition::has_on_road_condition() const {
  return condition_case() == kOnRoadCondition;
}
inline void Condition::set_has_on_road_condition() {
  _oneof_case_[0] = kOnRoadCondition;
}
inline void Condition::clear_on_road_condition() {
  if (has_on_road_condition()) {
    delete condition_.on_road_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::OnRoadCondition& Condition::_internal_on_road_condition() const {
  return *condition_.on_road_condition_;
}
inline ::apollo::simulation::OnRoadCondition* Condition::release_on_road_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.on_road_condition)
  if (has_on_road_condition()) {
    clear_has_condition();
      ::apollo::simulation::OnRoadCondition* temp = condition_.on_road_condition_;
    condition_.on_road_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::OnRoadCondition& Condition::on_road_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.on_road_condition)
  return has_on_road_condition()
      ? *condition_.on_road_condition_
      : *reinterpret_cast< ::apollo::simulation::OnRoadCondition*>(&::apollo::simulation::_OnRoadCondition_default_instance_);
}
inline ::apollo::simulation::OnRoadCondition* Condition::mutable_on_road_condition() {
  if (!has_on_road_condition()) {
    clear_condition();
    set_has_on_road_condition();
    condition_.on_road_condition_ = CreateMaybeMessage< ::apollo::simulation::OnRoadCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.on_road_condition)
  return condition_.on_road_condition_;
}

// optional .apollo.simulation.RunRedLightCondition run_red_light_condition = 10;
inline bool Condition::has_run_red_light_condition() const {
  return condition_case() == kRunRedLightCondition;
}
inline void Condition::set_has_run_red_light_condition() {
  _oneof_case_[0] = kRunRedLightCondition;
}
inline void Condition::clear_run_red_light_condition() {
  if (has_run_red_light_condition()) {
    delete condition_.run_red_light_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::RunRedLightCondition& Condition::_internal_run_red_light_condition() const {
  return *condition_.run_red_light_condition_;
}
inline ::apollo::simulation::RunRedLightCondition* Condition::release_run_red_light_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.run_red_light_condition)
  if (has_run_red_light_condition()) {
    clear_has_condition();
      ::apollo::simulation::RunRedLightCondition* temp = condition_.run_red_light_condition_;
    condition_.run_red_light_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::RunRedLightCondition& Condition::run_red_light_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.run_red_light_condition)
  return has_run_red_light_condition()
      ? *condition_.run_red_light_condition_
      : *reinterpret_cast< ::apollo::simulation::RunRedLightCondition*>(&::apollo::simulation::_RunRedLightCondition_default_instance_);
}
inline ::apollo::simulation::RunRedLightCondition* Condition::mutable_run_red_light_condition() {
  if (!has_run_red_light_condition()) {
    clear_condition();
    set_has_run_red_light_condition();
    condition_.run_red_light_condition_ = CreateMaybeMessage< ::apollo::simulation::RunRedLightCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.run_red_light_condition)
  return condition_.run_red_light_condition_;
}

// optional .apollo.simulation.ChangeLaneAtJunctionCondition change_lane_at_junction_condition = 11;
inline bool Condition::has_change_lane_at_junction_condition() const {
  return condition_case() == kChangeLaneAtJunctionCondition;
}
inline void Condition::set_has_change_lane_at_junction_condition() {
  _oneof_case_[0] = kChangeLaneAtJunctionCondition;
}
inline void Condition::clear_change_lane_at_junction_condition() {
  if (has_change_lane_at_junction_condition()) {
    delete condition_.change_lane_at_junction_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::ChangeLaneAtJunctionCondition& Condition::_internal_change_lane_at_junction_condition() const {
  return *condition_.change_lane_at_junction_condition_;
}
inline ::apollo::simulation::ChangeLaneAtJunctionCondition* Condition::release_change_lane_at_junction_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.change_lane_at_junction_condition)
  if (has_change_lane_at_junction_condition()) {
    clear_has_condition();
      ::apollo::simulation::ChangeLaneAtJunctionCondition* temp = condition_.change_lane_at_junction_condition_;
    condition_.change_lane_at_junction_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::ChangeLaneAtJunctionCondition& Condition::change_lane_at_junction_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.change_lane_at_junction_condition)
  return has_change_lane_at_junction_condition()
      ? *condition_.change_lane_at_junction_condition_
      : *reinterpret_cast< ::apollo::simulation::ChangeLaneAtJunctionCondition*>(&::apollo::simulation::_ChangeLaneAtJunctionCondition_default_instance_);
}
inline ::apollo::simulation::ChangeLaneAtJunctionCondition* Condition::mutable_change_lane_at_junction_condition() {
  if (!has_change_lane_at_junction_condition()) {
    clear_condition();
    set_has_change_lane_at_junction_condition();
    condition_.change_lane_at_junction_condition_ = CreateMaybeMessage< ::apollo::simulation::ChangeLaneAtJunctionCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.change_lane_at_junction_condition)
  return condition_.change_lane_at_junction_condition_;
}

// optional .apollo.simulation.RoutingCondition routing_condition = 12;
inline bool Condition::has_routing_condition() const {
  return condition_case() == kRoutingCondition;
}
inline void Condition::set_has_routing_condition() {
  _oneof_case_[0] = kRoutingCondition;
}
inline void Condition::clear_routing_condition() {
  if (has_routing_condition()) {
    delete condition_.routing_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::RoutingCondition& Condition::_internal_routing_condition() const {
  return *condition_.routing_condition_;
}
inline ::apollo::simulation::RoutingCondition* Condition::release_routing_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.routing_condition)
  if (has_routing_condition()) {
    clear_has_condition();
      ::apollo::simulation::RoutingCondition* temp = condition_.routing_condition_;
    condition_.routing_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::RoutingCondition& Condition::routing_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.routing_condition)
  return has_routing_condition()
      ? *condition_.routing_condition_
      : *reinterpret_cast< ::apollo::simulation::RoutingCondition*>(&::apollo::simulation::_RoutingCondition_default_instance_);
}
inline ::apollo::simulation::RoutingCondition* Condition::mutable_routing_condition() {
  if (!has_routing_condition()) {
    clear_condition();
    set_has_routing_condition();
    condition_.routing_condition_ = CreateMaybeMessage< ::apollo::simulation::RoutingCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.routing_condition)
  return condition_.routing_condition_;
}

// optional .apollo.simulation.CrosswalkYieldCondition crosswalk_yield_condition = 13;
inline bool Condition::has_crosswalk_yield_condition() const {
  return condition_case() == kCrosswalkYieldCondition;
}
inline void Condition::set_has_crosswalk_yield_condition() {
  _oneof_case_[0] = kCrosswalkYieldCondition;
}
inline void Condition::clear_crosswalk_yield_condition() {
  if (has_crosswalk_yield_condition()) {
    delete condition_.crosswalk_yield_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::CrosswalkYieldCondition& Condition::_internal_crosswalk_yield_condition() const {
  return *condition_.crosswalk_yield_condition_;
}
inline ::apollo::simulation::CrosswalkYieldCondition* Condition::release_crosswalk_yield_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.crosswalk_yield_condition)
  if (has_crosswalk_yield_condition()) {
    clear_has_condition();
      ::apollo::simulation::CrosswalkYieldCondition* temp = condition_.crosswalk_yield_condition_;
    condition_.crosswalk_yield_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::CrosswalkYieldCondition& Condition::crosswalk_yield_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.crosswalk_yield_condition)
  return has_crosswalk_yield_condition()
      ? *condition_.crosswalk_yield_condition_
      : *reinterpret_cast< ::apollo::simulation::CrosswalkYieldCondition*>(&::apollo::simulation::_CrosswalkYieldCondition_default_instance_);
}
inline ::apollo::simulation::CrosswalkYieldCondition* Condition::mutable_crosswalk_yield_condition() {
  if (!has_crosswalk_yield_condition()) {
    clear_condition();
    set_has_crosswalk_yield_condition();
    condition_.crosswalk_yield_condition_ = CreateMaybeMessage< ::apollo::simulation::CrosswalkYieldCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.crosswalk_yield_condition)
  return condition_.crosswalk_yield_condition_;
}

// optional .apollo.simulation.AbnormalStopCondition abnormal_stop_condition = 14;
inline bool Condition::has_abnormal_stop_condition() const {
  return condition_case() == kAbnormalStopCondition;
}
inline void Condition::set_has_abnormal_stop_condition() {
  _oneof_case_[0] = kAbnormalStopCondition;
}
inline void Condition::clear_abnormal_stop_condition() {
  if (has_abnormal_stop_condition()) {
    delete condition_.abnormal_stop_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::AbnormalStopCondition& Condition::_internal_abnormal_stop_condition() const {
  return *condition_.abnormal_stop_condition_;
}
inline ::apollo::simulation::AbnormalStopCondition* Condition::release_abnormal_stop_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.abnormal_stop_condition)
  if (has_abnormal_stop_condition()) {
    clear_has_condition();
      ::apollo::simulation::AbnormalStopCondition* temp = condition_.abnormal_stop_condition_;
    condition_.abnormal_stop_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::AbnormalStopCondition& Condition::abnormal_stop_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.abnormal_stop_condition)
  return has_abnormal_stop_condition()
      ? *condition_.abnormal_stop_condition_
      : *reinterpret_cast< ::apollo::simulation::AbnormalStopCondition*>(&::apollo::simulation::_AbnormalStopCondition_default_instance_);
}
inline ::apollo::simulation::AbnormalStopCondition* Condition::mutable_abnormal_stop_condition() {
  if (!has_abnormal_stop_condition()) {
    clear_condition();
    set_has_abnormal_stop_condition();
    condition_.abnormal_stop_condition_ = CreateMaybeMessage< ::apollo::simulation::AbnormalStopCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.abnormal_stop_condition)
  return condition_.abnormal_stop_condition_;
}

// optional .apollo.simulation.BrakeTapCondition brake_tap_condition = 15;
inline bool Condition::has_brake_tap_condition() const {
  return condition_case() == kBrakeTapCondition;
}
inline void Condition::set_has_brake_tap_condition() {
  _oneof_case_[0] = kBrakeTapCondition;
}
inline void Condition::clear_brake_tap_condition() {
  if (has_brake_tap_condition()) {
    delete condition_.brake_tap_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::BrakeTapCondition& Condition::_internal_brake_tap_condition() const {
  return *condition_.brake_tap_condition_;
}
inline ::apollo::simulation::BrakeTapCondition* Condition::release_brake_tap_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.brake_tap_condition)
  if (has_brake_tap_condition()) {
    clear_has_condition();
      ::apollo::simulation::BrakeTapCondition* temp = condition_.brake_tap_condition_;
    condition_.brake_tap_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::BrakeTapCondition& Condition::brake_tap_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.brake_tap_condition)
  return has_brake_tap_condition()
      ? *condition_.brake_tap_condition_
      : *reinterpret_cast< ::apollo::simulation::BrakeTapCondition*>(&::apollo::simulation::_BrakeTapCondition_default_instance_);
}
inline ::apollo::simulation::BrakeTapCondition* Condition::mutable_brake_tap_condition() {
  if (!has_brake_tap_condition()) {
    clear_condition();
    set_has_brake_tap_condition();
    condition_.brake_tap_condition_ = CreateMaybeMessage< ::apollo::simulation::BrakeTapCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.brake_tap_condition)
  return condition_.brake_tap_condition_;
}

// optional .apollo.simulation.RunStopSignCondition run_stop_sign_condition = 16;
inline bool Condition::has_run_stop_sign_condition() const {
  return condition_case() == kRunStopSignCondition;
}
inline void Condition::set_has_run_stop_sign_condition() {
  _oneof_case_[0] = kRunStopSignCondition;
}
inline void Condition::clear_run_stop_sign_condition() {
  if (has_run_stop_sign_condition()) {
    delete condition_.run_stop_sign_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::RunStopSignCondition& Condition::_internal_run_stop_sign_condition() const {
  return *condition_.run_stop_sign_condition_;
}
inline ::apollo::simulation::RunStopSignCondition* Condition::release_run_stop_sign_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.run_stop_sign_condition)
  if (has_run_stop_sign_condition()) {
    clear_has_condition();
      ::apollo::simulation::RunStopSignCondition* temp = condition_.run_stop_sign_condition_;
    condition_.run_stop_sign_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::RunStopSignCondition& Condition::run_stop_sign_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.run_stop_sign_condition)
  return has_run_stop_sign_condition()
      ? *condition_.run_stop_sign_condition_
      : *reinterpret_cast< ::apollo::simulation::RunStopSignCondition*>(&::apollo::simulation::_RunStopSignCondition_default_instance_);
}
inline ::apollo::simulation::RunStopSignCondition* Condition::mutable_run_stop_sign_condition() {
  if (!has_run_stop_sign_condition()) {
    clear_condition();
    set_has_run_stop_sign_condition();
    condition_.run_stop_sign_condition_ = CreateMaybeMessage< ::apollo::simulation::RunStopSignCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.run_stop_sign_condition)
  return condition_.run_stop_sign_condition_;
}

// optional .apollo.simulation.CheckpointCondition checkpoint_condition = 17;
inline bool Condition::has_checkpoint_condition() const {
  return condition_case() == kCheckpointCondition;
}
inline void Condition::set_has_checkpoint_condition() {
  _oneof_case_[0] = kCheckpointCondition;
}
inline void Condition::clear_checkpoint_condition() {
  if (has_checkpoint_condition()) {
    delete condition_.checkpoint_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::CheckpointCondition& Condition::_internal_checkpoint_condition() const {
  return *condition_.checkpoint_condition_;
}
inline ::apollo::simulation::CheckpointCondition* Condition::release_checkpoint_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.checkpoint_condition)
  if (has_checkpoint_condition()) {
    clear_has_condition();
      ::apollo::simulation::CheckpointCondition* temp = condition_.checkpoint_condition_;
    condition_.checkpoint_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::CheckpointCondition& Condition::checkpoint_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.checkpoint_condition)
  return has_checkpoint_condition()
      ? *condition_.checkpoint_condition_
      : *reinterpret_cast< ::apollo::simulation::CheckpointCondition*>(&::apollo::simulation::_CheckpointCondition_default_instance_);
}
inline ::apollo::simulation::CheckpointCondition* Condition::mutable_checkpoint_condition() {
  if (!has_checkpoint_condition()) {
    clear_condition();
    set_has_checkpoint_condition();
    condition_.checkpoint_condition_ = CreateMaybeMessage< ::apollo::simulation::CheckpointCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.checkpoint_condition)
  return condition_.checkpoint_condition_;
}

// optional .apollo.simulation.DistToEndCondition dist_to_end_condition = 18;
inline bool Condition::has_dist_to_end_condition() const {
  return condition_case() == kDistToEndCondition;
}
inline void Condition::set_has_dist_to_end_condition() {
  _oneof_case_[0] = kDistToEndCondition;
}
inline void Condition::clear_dist_to_end_condition() {
  if (has_dist_to_end_condition()) {
    delete condition_.dist_to_end_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::DistToEndCondition& Condition::_internal_dist_to_end_condition() const {
  return *condition_.dist_to_end_condition_;
}
inline ::apollo::simulation::DistToEndCondition* Condition::release_dist_to_end_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.dist_to_end_condition)
  if (has_dist_to_end_condition()) {
    clear_has_condition();
      ::apollo::simulation::DistToEndCondition* temp = condition_.dist_to_end_condition_;
    condition_.dist_to_end_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::DistToEndCondition& Condition::dist_to_end_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.dist_to_end_condition)
  return has_dist_to_end_condition()
      ? *condition_.dist_to_end_condition_
      : *reinterpret_cast< ::apollo::simulation::DistToEndCondition*>(&::apollo::simulation::_DistToEndCondition_default_instance_);
}
inline ::apollo::simulation::DistToEndCondition* Condition::mutable_dist_to_end_condition() {
  if (!has_dist_to_end_condition()) {
    clear_condition();
    set_has_dist_to_end_condition();
    condition_.dist_to_end_condition_ = CreateMaybeMessage< ::apollo::simulation::DistToEndCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.dist_to_end_condition)
  return condition_.dist_to_end_condition_;
}

// optional .apollo.simulation.DistToLaneCenterCondition dist_to_lane_center_condition = 19;
inline bool Condition::has_dist_to_lane_center_condition() const {
  return condition_case() == kDistToLaneCenterCondition;
}
inline void Condition::set_has_dist_to_lane_center_condition() {
  _oneof_case_[0] = kDistToLaneCenterCondition;
}
inline void Condition::clear_dist_to_lane_center_condition() {
  if (has_dist_to_lane_center_condition()) {
    delete condition_.dist_to_lane_center_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::DistToLaneCenterCondition& Condition::_internal_dist_to_lane_center_condition() const {
  return *condition_.dist_to_lane_center_condition_;
}
inline ::apollo::simulation::DistToLaneCenterCondition* Condition::release_dist_to_lane_center_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.dist_to_lane_center_condition)
  if (has_dist_to_lane_center_condition()) {
    clear_has_condition();
      ::apollo::simulation::DistToLaneCenterCondition* temp = condition_.dist_to_lane_center_condition_;
    condition_.dist_to_lane_center_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::DistToLaneCenterCondition& Condition::dist_to_lane_center_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.dist_to_lane_center_condition)
  return has_dist_to_lane_center_condition()
      ? *condition_.dist_to_lane_center_condition_
      : *reinterpret_cast< ::apollo::simulation::DistToLaneCenterCondition*>(&::apollo::simulation::_DistToLaneCenterCondition_default_instance_);
}
inline ::apollo::simulation::DistToLaneCenterCondition* Condition::mutable_dist_to_lane_center_condition() {
  if (!has_dist_to_lane_center_condition()) {
    clear_condition();
    set_has_dist_to_lane_center_condition();
    condition_.dist_to_lane_center_condition_ = CreateMaybeMessage< ::apollo::simulation::DistToLaneCenterCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.dist_to_lane_center_condition)
  return condition_.dist_to_lane_center_condition_;
}

// optional .apollo.simulation.CrosswalkStopCondition crosswalk_stop_condition = 20;
inline bool Condition::has_crosswalk_stop_condition() const {
  return condition_case() == kCrosswalkStopCondition;
}
inline void Condition::set_has_crosswalk_stop_condition() {
  _oneof_case_[0] = kCrosswalkStopCondition;
}
inline void Condition::clear_crosswalk_stop_condition() {
  if (has_crosswalk_stop_condition()) {
    delete condition_.crosswalk_stop_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::CrosswalkStopCondition& Condition::_internal_crosswalk_stop_condition() const {
  return *condition_.crosswalk_stop_condition_;
}
inline ::apollo::simulation::CrosswalkStopCondition* Condition::release_crosswalk_stop_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.crosswalk_stop_condition)
  if (has_crosswalk_stop_condition()) {
    clear_has_condition();
      ::apollo::simulation::CrosswalkStopCondition* temp = condition_.crosswalk_stop_condition_;
    condition_.crosswalk_stop_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::CrosswalkStopCondition& Condition::crosswalk_stop_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.crosswalk_stop_condition)
  return has_crosswalk_stop_condition()
      ? *condition_.crosswalk_stop_condition_
      : *reinterpret_cast< ::apollo::simulation::CrosswalkStopCondition*>(&::apollo::simulation::_CrosswalkStopCondition_default_instance_);
}
inline ::apollo::simulation::CrosswalkStopCondition* Condition::mutable_crosswalk_stop_condition() {
  if (!has_crosswalk_stop_condition()) {
    clear_condition();
    set_has_crosswalk_stop_condition();
    condition_.crosswalk_stop_condition_ = CreateMaybeMessage< ::apollo::simulation::CrosswalkStopCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.crosswalk_stop_condition)
  return condition_.crosswalk_stop_condition_;
}

// optional .apollo.simulation.RedLightStopCondition red_light_stop_condition = 21;
inline bool Condition::has_red_light_stop_condition() const {
  return condition_case() == kRedLightStopCondition;
}
inline void Condition::set_has_red_light_stop_condition() {
  _oneof_case_[0] = kRedLightStopCondition;
}
inline void Condition::clear_red_light_stop_condition() {
  if (has_red_light_stop_condition()) {
    delete condition_.red_light_stop_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::RedLightStopCondition& Condition::_internal_red_light_stop_condition() const {
  return *condition_.red_light_stop_condition_;
}
inline ::apollo::simulation::RedLightStopCondition* Condition::release_red_light_stop_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.red_light_stop_condition)
  if (has_red_light_stop_condition()) {
    clear_has_condition();
      ::apollo::simulation::RedLightStopCondition* temp = condition_.red_light_stop_condition_;
    condition_.red_light_stop_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::RedLightStopCondition& Condition::red_light_stop_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.red_light_stop_condition)
  return has_red_light_stop_condition()
      ? *condition_.red_light_stop_condition_
      : *reinterpret_cast< ::apollo::simulation::RedLightStopCondition*>(&::apollo::simulation::_RedLightStopCondition_default_instance_);
}
inline ::apollo::simulation::RedLightStopCondition* Condition::mutable_red_light_stop_condition() {
  if (!has_red_light_stop_condition()) {
    clear_condition();
    set_has_red_light_stop_condition();
    condition_.red_light_stop_condition_ = CreateMaybeMessage< ::apollo::simulation::RedLightStopCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.red_light_stop_condition)
  return condition_.red_light_stop_condition_;
}

// optional .apollo.simulation.SpeedbumpLimitCondition speedbump_limit_condition = 22;
inline bool Condition::has_speedbump_limit_condition() const {
  return condition_case() == kSpeedbumpLimitCondition;
}
inline void Condition::set_has_speedbump_limit_condition() {
  _oneof_case_[0] = kSpeedbumpLimitCondition;
}
inline void Condition::clear_speedbump_limit_condition() {
  if (has_speedbump_limit_condition()) {
    delete condition_.speedbump_limit_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::SpeedbumpLimitCondition& Condition::_internal_speedbump_limit_condition() const {
  return *condition_.speedbump_limit_condition_;
}
inline ::apollo::simulation::SpeedbumpLimitCondition* Condition::release_speedbump_limit_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.speedbump_limit_condition)
  if (has_speedbump_limit_condition()) {
    clear_has_condition();
      ::apollo::simulation::SpeedbumpLimitCondition* temp = condition_.speedbump_limit_condition_;
    condition_.speedbump_limit_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::SpeedbumpLimitCondition& Condition::speedbump_limit_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.speedbump_limit_condition)
  return has_speedbump_limit_condition()
      ? *condition_.speedbump_limit_condition_
      : *reinterpret_cast< ::apollo::simulation::SpeedbumpLimitCondition*>(&::apollo::simulation::_SpeedbumpLimitCondition_default_instance_);
}
inline ::apollo::simulation::SpeedbumpLimitCondition* Condition::mutable_speedbump_limit_condition() {
  if (!has_speedbump_limit_condition()) {
    clear_condition();
    set_has_speedbump_limit_condition();
    condition_.speedbump_limit_condition_ = CreateMaybeMessage< ::apollo::simulation::SpeedbumpLimitCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.speedbump_limit_condition)
  return condition_.speedbump_limit_condition_;
}

// optional .apollo.simulation.WorkingZoneAvoidLimitCondition working_zone_avoid_limit_condition = 23;
inline bool Condition::has_working_zone_avoid_limit_condition() const {
  return condition_case() == kWorkingZoneAvoidLimitCondition;
}
inline void Condition::set_has_working_zone_avoid_limit_condition() {
  _oneof_case_[0] = kWorkingZoneAvoidLimitCondition;
}
inline void Condition::clear_working_zone_avoid_limit_condition() {
  if (has_working_zone_avoid_limit_condition()) {
    delete condition_.working_zone_avoid_limit_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::WorkingZoneAvoidLimitCondition& Condition::_internal_working_zone_avoid_limit_condition() const {
  return *condition_.working_zone_avoid_limit_condition_;
}
inline ::apollo::simulation::WorkingZoneAvoidLimitCondition* Condition::release_working_zone_avoid_limit_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  if (has_working_zone_avoid_limit_condition()) {
    clear_has_condition();
      ::apollo::simulation::WorkingZoneAvoidLimitCondition* temp = condition_.working_zone_avoid_limit_condition_;
    condition_.working_zone_avoid_limit_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::WorkingZoneAvoidLimitCondition& Condition::working_zone_avoid_limit_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  return has_working_zone_avoid_limit_condition()
      ? *condition_.working_zone_avoid_limit_condition_
      : *reinterpret_cast< ::apollo::simulation::WorkingZoneAvoidLimitCondition*>(&::apollo::simulation::_WorkingZoneAvoidLimitCondition_default_instance_);
}
inline ::apollo::simulation::WorkingZoneAvoidLimitCondition* Condition::mutable_working_zone_avoid_limit_condition() {
  if (!has_working_zone_avoid_limit_condition()) {
    clear_condition();
    set_has_working_zone_avoid_limit_condition();
    condition_.working_zone_avoid_limit_condition_ = CreateMaybeMessage< ::apollo::simulation::WorkingZoneAvoidLimitCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  return condition_.working_zone_avoid_limit_condition_;
}

// optional .apollo.simulation.LimitedTimeParkingCondition limited_time_parking_condition = 24;
inline bool Condition::has_limited_time_parking_condition() const {
  return condition_case() == kLimitedTimeParkingCondition;
}
inline void Condition::set_has_limited_time_parking_condition() {
  _oneof_case_[0] = kLimitedTimeParkingCondition;
}
inline void Condition::clear_limited_time_parking_condition() {
  if (has_limited_time_parking_condition()) {
    delete condition_.limited_time_parking_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::LimitedTimeParkingCondition& Condition::_internal_limited_time_parking_condition() const {
  return *condition_.limited_time_parking_condition_;
}
inline ::apollo::simulation::LimitedTimeParkingCondition* Condition::release_limited_time_parking_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.limited_time_parking_condition)
  if (has_limited_time_parking_condition()) {
    clear_has_condition();
      ::apollo::simulation::LimitedTimeParkingCondition* temp = condition_.limited_time_parking_condition_;
    condition_.limited_time_parking_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::LimitedTimeParkingCondition& Condition::limited_time_parking_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.limited_time_parking_condition)
  return has_limited_time_parking_condition()
      ? *condition_.limited_time_parking_condition_
      : *reinterpret_cast< ::apollo::simulation::LimitedTimeParkingCondition*>(&::apollo::simulation::_LimitedTimeParkingCondition_default_instance_);
}
inline ::apollo::simulation::LimitedTimeParkingCondition* Condition::mutable_limited_time_parking_condition() {
  if (!has_limited_time_parking_condition()) {
    clear_condition();
    set_has_limited_time_parking_condition();
    condition_.limited_time_parking_condition_ = CreateMaybeMessage< ::apollo::simulation::LimitedTimeParkingCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.limited_time_parking_condition)
  return condition_.limited_time_parking_condition_;
}

// optional .apollo.simulation.FollowAndBypassCondition follow_and_bypass_condition = 25;
inline bool Condition::has_follow_and_bypass_condition() const {
  return condition_case() == kFollowAndBypassCondition;
}
inline void Condition::set_has_follow_and_bypass_condition() {
  _oneof_case_[0] = kFollowAndBypassCondition;
}
inline void Condition::clear_follow_and_bypass_condition() {
  if (has_follow_and_bypass_condition()) {
    delete condition_.follow_and_bypass_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::FollowAndBypassCondition& Condition::_internal_follow_and_bypass_condition() const {
  return *condition_.follow_and_bypass_condition_;
}
inline ::apollo::simulation::FollowAndBypassCondition* Condition::release_follow_and_bypass_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.follow_and_bypass_condition)
  if (has_follow_and_bypass_condition()) {
    clear_has_condition();
      ::apollo::simulation::FollowAndBypassCondition* temp = condition_.follow_and_bypass_condition_;
    condition_.follow_and_bypass_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::FollowAndBypassCondition& Condition::follow_and_bypass_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.follow_and_bypass_condition)
  return has_follow_and_bypass_condition()
      ? *condition_.follow_and_bypass_condition_
      : *reinterpret_cast< ::apollo::simulation::FollowAndBypassCondition*>(&::apollo::simulation::_FollowAndBypassCondition_default_instance_);
}
inline ::apollo::simulation::FollowAndBypassCondition* Condition::mutable_follow_and_bypass_condition() {
  if (!has_follow_and_bypass_condition()) {
    clear_condition();
    set_has_follow_and_bypass_condition();
    condition_.follow_and_bypass_condition_ = CreateMaybeMessage< ::apollo::simulation::FollowAndBypassCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.follow_and_bypass_condition)
  return condition_.follow_and_bypass_condition_;
}

// optional .apollo.simulation.ObstacleBypassCondition obstacle_bypass_condition = 26;
inline bool Condition::has_obstacle_bypass_condition() const {
  return condition_case() == kObstacleBypassCondition;
}
inline void Condition::set_has_obstacle_bypass_condition() {
  _oneof_case_[0] = kObstacleBypassCondition;
}
inline void Condition::clear_obstacle_bypass_condition() {
  if (has_obstacle_bypass_condition()) {
    delete condition_.obstacle_bypass_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::ObstacleBypassCondition& Condition::_internal_obstacle_bypass_condition() const {
  return *condition_.obstacle_bypass_condition_;
}
inline ::apollo::simulation::ObstacleBypassCondition* Condition::release_obstacle_bypass_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.obstacle_bypass_condition)
  if (has_obstacle_bypass_condition()) {
    clear_has_condition();
      ::apollo::simulation::ObstacleBypassCondition* temp = condition_.obstacle_bypass_condition_;
    condition_.obstacle_bypass_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::ObstacleBypassCondition& Condition::obstacle_bypass_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.obstacle_bypass_condition)
  return has_obstacle_bypass_condition()
      ? *condition_.obstacle_bypass_condition_
      : *reinterpret_cast< ::apollo::simulation::ObstacleBypassCondition*>(&::apollo::simulation::_ObstacleBypassCondition_default_instance_);
}
inline ::apollo::simulation::ObstacleBypassCondition* Condition::mutable_obstacle_bypass_condition() {
  if (!has_obstacle_bypass_condition()) {
    clear_condition();
    set_has_obstacle_bypass_condition();
    condition_.obstacle_bypass_condition_ = CreateMaybeMessage< ::apollo::simulation::ObstacleBypassCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.obstacle_bypass_condition)
  return condition_.obstacle_bypass_condition_;
}

// optional .apollo.simulation.CentripetalAccelerationCondition centripetal_acceleration_condition = 27;
inline bool Condition::has_centripetal_acceleration_condition() const {
  return condition_case() == kCentripetalAccelerationCondition;
}
inline void Condition::set_has_centripetal_acceleration_condition() {
  _oneof_case_[0] = kCentripetalAccelerationCondition;
}
inline void Condition::clear_centripetal_acceleration_condition() {
  if (has_centripetal_acceleration_condition()) {
    delete condition_.centripetal_acceleration_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::CentripetalAccelerationCondition& Condition::_internal_centripetal_acceleration_condition() const {
  return *condition_.centripetal_acceleration_condition_;
}
inline ::apollo::simulation::CentripetalAccelerationCondition* Condition::release_centripetal_acceleration_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.centripetal_acceleration_condition)
  if (has_centripetal_acceleration_condition()) {
    clear_has_condition();
      ::apollo::simulation::CentripetalAccelerationCondition* temp = condition_.centripetal_acceleration_condition_;
    condition_.centripetal_acceleration_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::CentripetalAccelerationCondition& Condition::centripetal_acceleration_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.centripetal_acceleration_condition)
  return has_centripetal_acceleration_condition()
      ? *condition_.centripetal_acceleration_condition_
      : *reinterpret_cast< ::apollo::simulation::CentripetalAccelerationCondition*>(&::apollo::simulation::_CentripetalAccelerationCondition_default_instance_);
}
inline ::apollo::simulation::CentripetalAccelerationCondition* Condition::mutable_centripetal_acceleration_condition() {
  if (!has_centripetal_acceleration_condition()) {
    clear_condition();
    set_has_centripetal_acceleration_condition();
    condition_.centripetal_acceleration_condition_ = CreateMaybeMessage< ::apollo::simulation::CentripetalAccelerationCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.centripetal_acceleration_condition)
  return condition_.centripetal_acceleration_condition_;
}

// optional .apollo.simulation.TimeLimitCondition time_limit_condition = 28;
inline bool Condition::has_time_limit_condition() const {
  return condition_case() == kTimeLimitCondition;
}
inline void Condition::set_has_time_limit_condition() {
  _oneof_case_[0] = kTimeLimitCondition;
}
inline void Condition::clear_time_limit_condition() {
  if (has_time_limit_condition()) {
    delete condition_.time_limit_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::TimeLimitCondition& Condition::_internal_time_limit_condition() const {
  return *condition_.time_limit_condition_;
}
inline ::apollo::simulation::TimeLimitCondition* Condition::release_time_limit_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.time_limit_condition)
  if (has_time_limit_condition()) {
    clear_has_condition();
      ::apollo::simulation::TimeLimitCondition* temp = condition_.time_limit_condition_;
    condition_.time_limit_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::TimeLimitCondition& Condition::time_limit_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.time_limit_condition)
  return has_time_limit_condition()
      ? *condition_.time_limit_condition_
      : *reinterpret_cast< ::apollo::simulation::TimeLimitCondition*>(&::apollo::simulation::_TimeLimitCondition_default_instance_);
}
inline ::apollo::simulation::TimeLimitCondition* Condition::mutable_time_limit_condition() {
  if (!has_time_limit_condition()) {
    clear_condition();
    set_has_time_limit_condition();
    condition_.time_limit_condition_ = CreateMaybeMessage< ::apollo::simulation::TimeLimitCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.time_limit_condition)
  return condition_.time_limit_condition_;
}

// optional .apollo.simulation.AntiCheatingCondition anti_cheating_condition = 29;
inline bool Condition::has_anti_cheating_condition() const {
  return condition_case() == kAntiCheatingCondition;
}
inline void Condition::set_has_anti_cheating_condition() {
  _oneof_case_[0] = kAntiCheatingCondition;
}
inline void Condition::clear_anti_cheating_condition() {
  if (has_anti_cheating_condition()) {
    delete condition_.anti_cheating_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::AntiCheatingCondition& Condition::_internal_anti_cheating_condition() const {
  return *condition_.anti_cheating_condition_;
}
inline ::apollo::simulation::AntiCheatingCondition* Condition::release_anti_cheating_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.anti_cheating_condition)
  if (has_anti_cheating_condition()) {
    clear_has_condition();
      ::apollo::simulation::AntiCheatingCondition* temp = condition_.anti_cheating_condition_;
    condition_.anti_cheating_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::AntiCheatingCondition& Condition::anti_cheating_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.anti_cheating_condition)
  return has_anti_cheating_condition()
      ? *condition_.anti_cheating_condition_
      : *reinterpret_cast< ::apollo::simulation::AntiCheatingCondition*>(&::apollo::simulation::_AntiCheatingCondition_default_instance_);
}
inline ::apollo::simulation::AntiCheatingCondition* Condition::mutable_anti_cheating_condition() {
  if (!has_anti_cheating_condition()) {
    clear_condition();
    set_has_anti_cheating_condition();
    condition_.anti_cheating_condition_ = CreateMaybeMessage< ::apollo::simulation::AntiCheatingCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.anti_cheating_condition)
  return condition_.anti_cheating_condition_;
}

// optional .apollo.simulation.KeyPointCondition key_point_condition = 30;
inline bool Condition::has_key_point_condition() const {
  return condition_case() == kKeyPointCondition;
}
inline void Condition::set_has_key_point_condition() {
  _oneof_case_[0] = kKeyPointCondition;
}
inline void Condition::clear_key_point_condition() {
  if (has_key_point_condition()) {
    delete condition_.key_point_condition_;
    clear_has_condition();
  }
}
inline const ::apollo::simulation::KeyPointCondition& Condition::_internal_key_point_condition() const {
  return *condition_.key_point_condition_;
}
inline ::apollo::simulation::KeyPointCondition* Condition::release_key_point_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.key_point_condition)
  if (has_key_point_condition()) {
    clear_has_condition();
      ::apollo::simulation::KeyPointCondition* temp = condition_.key_point_condition_;
    condition_.key_point_condition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::simulation::KeyPointCondition& Condition::key_point_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.key_point_condition)
  return has_key_point_condition()
      ? *condition_.key_point_condition_
      : *reinterpret_cast< ::apollo::simulation::KeyPointCondition*>(&::apollo::simulation::_KeyPointCondition_default_instance_);
}
inline ::apollo::simulation::KeyPointCondition* Condition::mutable_key_point_condition() {
  if (!has_key_point_condition()) {
    clear_condition();
    set_has_key_point_condition();
    condition_.key_point_condition_ = CreateMaybeMessage< ::apollo::simulation::KeyPointCondition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.key_point_condition)
  return condition_.key_point_condition_;
}

// optional .apollo.simulation.GradePlanning grade_planning = 100;
inline bool Condition::has_grade_planning() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_grade_planning() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_grade_planning() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_grade_planning() {
  if (grade_planning_ != NULL) grade_planning_->Clear();
  clear_has_grade_planning();
}
inline const ::apollo::simulation::GradePlanning& Condition::_internal_grade_planning() const {
  return *grade_planning_;
}
inline const ::apollo::simulation::GradePlanning& Condition::grade_planning() const {
  const ::apollo::simulation::GradePlanning* p = grade_planning_;
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.grade_planning)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::simulation::GradePlanning*>(
      &::apollo::simulation::_GradePlanning_default_instance_);
}
inline ::apollo::simulation::GradePlanning* Condition::release_grade_planning() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.grade_planning)
  clear_has_grade_planning();
  ::apollo::simulation::GradePlanning* temp = grade_planning_;
  grade_planning_ = NULL;
  return temp;
}
inline ::apollo::simulation::GradePlanning* Condition::mutable_grade_planning() {
  set_has_grade_planning();
  if (grade_planning_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::simulation::GradePlanning>(GetArenaNoVirtual());
    grade_planning_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.grade_planning)
  return grade_planning_;
}
inline void Condition::set_allocated_grade_planning(::apollo::simulation::GradePlanning* grade_planning) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete grade_planning_;
  }
  if (grade_planning) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      grade_planning = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, grade_planning, submessage_arena);
    }
    set_has_grade_planning();
  } else {
    clear_has_grade_planning();
  }
  grade_planning_ = grade_planning;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.Condition.grade_planning)
}

inline bool Condition::has_condition() const {
  return condition_case() != CONDITION_NOT_SET;
}
inline void Condition::clear_has_condition() {
  _oneof_case_[0] = CONDITION_NOT_SET;
}
inline Condition::ConditionCase Condition::condition_case() const {
  return Condition::ConditionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GradePlanning

// optional sint32 duration = 1 [default = 0];
inline bool GradePlanning::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GradePlanning::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GradePlanning::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GradePlanning::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 GradePlanning::duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.GradePlanning.duration)
  return duration_;
}
inline void GradePlanning::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.GradePlanning.duration)
}

// optional bool update_obstacles = 2 [default = false];
inline bool GradePlanning::has_update_obstacles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GradePlanning::set_has_update_obstacles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GradePlanning::clear_has_update_obstacles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GradePlanning::clear_update_obstacles() {
  update_obstacles_ = false;
  clear_has_update_obstacles();
}
inline bool GradePlanning::update_obstacles() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.GradePlanning.update_obstacles)
  return update_obstacles_;
}
inline void GradePlanning::set_update_obstacles(bool value) {
  set_has_update_obstacles();
  update_obstacles_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.GradePlanning.update_obstacles)
}

// optional bool use_planning_as_history = 3 [default = false];
inline bool GradePlanning::has_use_planning_as_history() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GradePlanning::set_has_use_planning_as_history() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GradePlanning::clear_has_use_planning_as_history() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GradePlanning::clear_use_planning_as_history() {
  use_planning_as_history_ = false;
  clear_has_use_planning_as_history();
}
inline bool GradePlanning::use_planning_as_history() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.GradePlanning.use_planning_as_history)
  return use_planning_as_history_;
}
inline void GradePlanning::set_use_planning_as_history(bool value) {
  set_has_use_planning_as_history();
  use_planning_as_history_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.GradePlanning.use_planning_as_history)
}

// -------------------------------------------------------------------

// LogicalCondition

// optional .apollo.simulation.LogicalCondition.OperatorType operator_type = 1;
inline bool LogicalCondition::has_operator_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogicalCondition::set_has_operator_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogicalCondition::clear_has_operator_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogicalCondition::clear_operator_type() {
  operator_type_ = 0;
  clear_has_operator_type();
}
inline ::apollo::simulation::LogicalCondition_OperatorType LogicalCondition::operator_type() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LogicalCondition.operator_type)
  return static_cast< ::apollo::simulation::LogicalCondition_OperatorType >(operator_type_);
}
inline void LogicalCondition::set_operator_type(::apollo::simulation::LogicalCondition_OperatorType value) {
  assert(::apollo::simulation::LogicalCondition_OperatorType_IsValid(value));
  set_has_operator_type();
  operator_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.LogicalCondition.operator_type)
}

// repeated .apollo.simulation.Condition sub_condition = 2;
inline int LogicalCondition::sub_condition_size() const {
  return sub_condition_.size();
}
inline void LogicalCondition::clear_sub_condition() {
  sub_condition_.Clear();
}
inline ::apollo::simulation::Condition* LogicalCondition::mutable_sub_condition(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.LogicalCondition.sub_condition)
  return sub_condition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >*
LogicalCondition::mutable_sub_condition() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.LogicalCondition.sub_condition)
  return &sub_condition_;
}
inline const ::apollo::simulation::Condition& LogicalCondition::sub_condition(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LogicalCondition.sub_condition)
  return sub_condition_.Get(index);
}
inline ::apollo::simulation::Condition* LogicalCondition::add_sub_condition() {
  // @@protoc_insertion_point(field_add:apollo.simulation.LogicalCondition.sub_condition)
  return sub_condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >&
LogicalCondition::sub_condition() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.LogicalCondition.sub_condition)
  return sub_condition_;
}

// -------------------------------------------------------------------

// SpeedCondition

// optional string name = 1 [default = "speed"];
inline bool SpeedCondition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedCondition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedCondition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedCondition::clear_name() {
  name_.ClearToDefaultNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get());
  clear_has_name();
}
inline const ::std::string& SpeedCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.name)
  return name_.GetNoArena();
}
inline void SpeedCondition::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.name)
}
#if LANG_CXX11
inline void SpeedCondition::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.SpeedCondition.name)
}
#endif
inline void SpeedCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.SpeedCondition.name)
}
inline void SpeedCondition::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.SpeedCondition.name)
}
inline ::std::string* SpeedCondition::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.SpeedCondition.name)
  return name_.MutableNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline ::std::string* SpeedCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.SpeedCondition.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline void SpeedCondition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_.get(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.SpeedCondition.name)
}

// optional double min_speed = 2 [default = -0.5];
inline bool SpeedCondition::has_min_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeedCondition::set_has_min_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeedCondition::clear_has_min_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeedCondition::clear_min_speed() {
  min_speed_ = -0.5;
  clear_has_min_speed();
}
inline double SpeedCondition::min_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.min_speed)
  return min_speed_;
}
inline void SpeedCondition::set_min_speed(double value) {
  set_has_min_speed();
  min_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.min_speed)
}

// optional double max_speed = 3 [default = 1000];
inline bool SpeedCondition::has_max_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeedCondition::set_has_max_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeedCondition::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeedCondition::clear_max_speed() {
  max_speed_ = 1000;
  clear_has_max_speed();
}
inline double SpeedCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.max_speed)
  return max_speed_;
}
inline void SpeedCondition::set_max_speed(double value) {
  set_has_max_speed();
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.max_speed)
}

// optional bool use_score = 4 [default = false];
inline bool SpeedCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool SpeedCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.use_score)
  return use_score_;
}
inline void SpeedCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.use_score)
}

// optional double single_deduction = 5 [default = 0.5];
inline bool SpeedCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpeedCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpeedCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpeedCondition::clear_single_deduction() {
  single_deduction_ = 0.5;
  clear_has_single_deduction();
}
inline double SpeedCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.single_deduction)
  return single_deduction_;
}
inline void SpeedCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.single_deduction)
}

// -------------------------------------------------------------------

// CentripetalAccelerationCondition

// optional string name = 1 [default = "centripetal_acceleration"];
inline bool CentripetalAccelerationCondition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CentripetalAccelerationCondition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CentripetalAccelerationCondition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CentripetalAccelerationCondition::clear_name() {
  name_.ClearToDefaultNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get());
  clear_has_name();
}
inline const ::std::string& CentripetalAccelerationCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.name)
  return name_.GetNoArena();
}
inline void CentripetalAccelerationCondition::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.name)
}
#if LANG_CXX11
inline void CentripetalAccelerationCondition::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.CentripetalAccelerationCondition.name)
}
#endif
inline void CentripetalAccelerationCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.CentripetalAccelerationCondition.name)
}
inline void CentripetalAccelerationCondition::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.CentripetalAccelerationCondition.name)
}
inline ::std::string* CentripetalAccelerationCondition::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.CentripetalAccelerationCondition.name)
  return name_.MutableNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline ::std::string* CentripetalAccelerationCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.CentripetalAccelerationCondition.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline void CentripetalAccelerationCondition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.CentripetalAccelerationCondition.name)
}

// optional double max_centripetal_acceleration = 2 [default = 2];
inline bool CentripetalAccelerationCondition::has_max_centripetal_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CentripetalAccelerationCondition::set_has_max_centripetal_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CentripetalAccelerationCondition::clear_has_max_centripetal_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CentripetalAccelerationCondition::clear_max_centripetal_acceleration() {
  max_centripetal_acceleration_ = 2;
  clear_has_max_centripetal_acceleration();
}
inline double CentripetalAccelerationCondition::max_centripetal_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.max_centripetal_acceleration)
  return max_centripetal_acceleration_;
}
inline void CentripetalAccelerationCondition::set_max_centripetal_acceleration(double value) {
  set_has_max_centripetal_acceleration();
  max_centripetal_acceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.max_centripetal_acceleration)
}

// optional bool use_score = 3 [default = false];
inline bool CentripetalAccelerationCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CentripetalAccelerationCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CentripetalAccelerationCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CentripetalAccelerationCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool CentripetalAccelerationCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.use_score)
  return use_score_;
}
inline void CentripetalAccelerationCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.use_score)
}

// optional double single_deduction = 4 [default = 0.5];
inline bool CentripetalAccelerationCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CentripetalAccelerationCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CentripetalAccelerationCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CentripetalAccelerationCondition::clear_single_deduction() {
  single_deduction_ = 0.5;
  clear_has_single_deduction();
}
inline double CentripetalAccelerationCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.single_deduction)
  return single_deduction_;
}
inline void CentripetalAccelerationCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.single_deduction)
}

// -------------------------------------------------------------------

// AccelerationCondition

// optional string name = 1 [default = "acceleration"];
inline bool AccelerationCondition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccelerationCondition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccelerationCondition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccelerationCondition::clear_name() {
  name_.ClearToDefaultNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get());
  clear_has_name();
}
inline const ::std::string& AccelerationCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.name)
  return name_.GetNoArena();
}
inline void AccelerationCondition::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.name)
}
#if LANG_CXX11
inline void AccelerationCondition::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.AccelerationCondition.name)
}
#endif
inline void AccelerationCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.AccelerationCondition.name)
}
inline void AccelerationCondition::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.AccelerationCondition.name)
}
inline ::std::string* AccelerationCondition::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.AccelerationCondition.name)
  return name_.MutableNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline ::std::string* AccelerationCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.AccelerationCondition.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline void AccelerationCondition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_.get(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.AccelerationCondition.name)
}

// optional double min_acceleration = 2 [default = -1000];
inline bool AccelerationCondition::has_min_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccelerationCondition::set_has_min_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccelerationCondition::clear_has_min_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccelerationCondition::clear_min_acceleration() {
  min_acceleration_ = -1000;
  clear_has_min_acceleration();
}
inline double AccelerationCondition::min_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.min_acceleration)
  return min_acceleration_;
}
inline void AccelerationCondition::set_min_acceleration(double value) {
  set_has_min_acceleration();
  min_acceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.min_acceleration)
}

// optional double max_acceleration = 3 [default = 1000];
inline bool AccelerationCondition::has_max_acceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccelerationCondition::set_has_max_acceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccelerationCondition::clear_has_max_acceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccelerationCondition::clear_max_acceleration() {
  max_acceleration_ = 1000;
  clear_has_max_acceleration();
}
inline double AccelerationCondition::max_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.max_acceleration)
  return max_acceleration_;
}
inline void AccelerationCondition::set_max_acceleration(double value) {
  set_has_max_acceleration();
  max_acceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.max_acceleration)
}

// optional bool use_score = 4 [default = false];
inline bool AccelerationCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccelerationCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccelerationCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccelerationCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool AccelerationCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.use_score)
  return use_score_;
}
inline void AccelerationCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.use_score)
}

// optional double single_deduction = 5 [default = 0.5];
inline bool AccelerationCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccelerationCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccelerationCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccelerationCondition::clear_single_deduction() {
  single_deduction_ = 0.5;
  clear_has_single_deduction();
}
inline double AccelerationCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.single_deduction)
  return single_deduction_;
}
inline void AccelerationCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.single_deduction)
}

// -------------------------------------------------------------------

// JerkCondition

// optional string name = 1 [default = "jerk"];
inline bool JerkCondition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JerkCondition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JerkCondition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JerkCondition::clear_name() {
  name_.ClearToDefaultNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get());
  clear_has_name();
}
inline const ::std::string& JerkCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.JerkCondition.name)
  return name_.GetNoArena();
}
inline void JerkCondition::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.JerkCondition.name)
}
#if LANG_CXX11
inline void JerkCondition::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.JerkCondition.name)
}
#endif
inline void JerkCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.JerkCondition.name)
}
inline void JerkCondition::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.JerkCondition.name)
}
inline ::std::string* JerkCondition::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.JerkCondition.name)
  return name_.MutableNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline ::std::string* JerkCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.JerkCondition.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline void JerkCondition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_.get(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.JerkCondition.name)
}

// optional double min_jerk = 2 [default = -1000];
inline bool JerkCondition::has_min_jerk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JerkCondition::set_has_min_jerk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JerkCondition::clear_has_min_jerk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JerkCondition::clear_min_jerk() {
  min_jerk_ = -1000;
  clear_has_min_jerk();
}
inline double JerkCondition::min_jerk() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.JerkCondition.min_jerk)
  return min_jerk_;
}
inline void JerkCondition::set_min_jerk(double value) {
  set_has_min_jerk();
  min_jerk_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.JerkCondition.min_jerk)
}

// optional double max_jerk = 3 [default = 1000];
inline bool JerkCondition::has_max_jerk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JerkCondition::set_has_max_jerk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JerkCondition::clear_has_max_jerk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JerkCondition::clear_max_jerk() {
  max_jerk_ = 1000;
  clear_has_max_jerk();
}
inline double JerkCondition::max_jerk() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.JerkCondition.max_jerk)
  return max_jerk_;
}
inline void JerkCondition::set_max_jerk(double value) {
  set_has_max_jerk();
  max_jerk_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.JerkCondition.max_jerk)
}

// -------------------------------------------------------------------

// SpinCondition

// optional string name = 1 [default = "spin"];
inline bool SpinCondition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpinCondition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpinCondition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpinCondition::clear_name() {
  name_.ClearToDefaultNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get());
  clear_has_name();
}
inline const ::std::string& SpinCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpinCondition.name)
  return name_.GetNoArena();
}
inline void SpinCondition::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpinCondition.name)
}
#if LANG_CXX11
inline void SpinCondition::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.SpinCondition.name)
}
#endif
inline void SpinCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.SpinCondition.name)
}
inline void SpinCondition::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.SpinCondition.name)
}
inline ::std::string* SpinCondition::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.SpinCondition.name)
  return name_.MutableNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline ::std::string* SpinCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.SpinCondition.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get());
}
inline void SpinCondition::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_.get(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.SpinCondition.name)
}

// optional double min_spin = 2 [default = -1000];
inline bool SpinCondition::has_min_spin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpinCondition::set_has_min_spin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpinCondition::clear_has_min_spin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpinCondition::clear_min_spin() {
  min_spin_ = -1000;
  clear_has_min_spin();
}
inline double SpinCondition::min_spin() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpinCondition.min_spin)
  return min_spin_;
}
inline void SpinCondition::set_min_spin(double value) {
  set_has_min_spin();
  min_spin_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpinCondition.min_spin)
}

// optional double max_spin = 3 [default = 1000];
inline bool SpinCondition::has_max_spin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpinCondition::set_has_max_spin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpinCondition::clear_has_max_spin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpinCondition::clear_max_spin() {
  max_spin_ = 1000;
  clear_has_max_spin();
}
inline double SpinCondition::max_spin() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpinCondition.max_spin)
  return max_spin_;
}
inline void SpinCondition::set_max_spin(double value) {
  set_has_max_spin();
  max_spin_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpinCondition.max_spin)
}

// -------------------------------------------------------------------

// ObjectOverlapCondition

// optional string source_object_ids = 1;
inline bool ObjectOverlapCondition::has_source_object_ids() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectOverlapCondition::set_has_source_object_ids() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectOverlapCondition::clear_has_source_object_ids() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectOverlapCondition::clear_source_object_ids() {
  source_object_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_object_ids();
}
inline const ::std::string& ObjectOverlapCondition::source_object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.source_object_ids)
  return source_object_ids_.GetNoArena();
}
inline void ObjectOverlapCondition::set_source_object_ids(const ::std::string& value) {
  set_has_source_object_ids();
  source_object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
#if LANG_CXX11
inline void ObjectOverlapCondition::set_source_object_ids(::std::string&& value) {
  set_has_source_object_ids();
  source_object_ids_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
#endif
inline void ObjectOverlapCondition::set_source_object_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_object_ids();
  source_object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
inline void ObjectOverlapCondition::set_source_object_ids(const char* value, size_t size) {
  set_has_source_object_ids();
  source_object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
inline ::std::string* ObjectOverlapCondition::mutable_source_object_ids() {
  set_has_source_object_ids();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObjectOverlapCondition.source_object_ids)
  return source_object_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectOverlapCondition::release_source_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObjectOverlapCondition.source_object_ids)
  if (!has_source_object_ids()) {
    return NULL;
  }
  clear_has_source_object_ids();
  return source_object_ids_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectOverlapCondition::set_allocated_source_object_ids(::std::string* source_object_ids) {
  if (source_object_ids != NULL) {
    set_has_source_object_ids();
  } else {
    clear_has_source_object_ids();
  }
  source_object_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_object_ids);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}

// optional string target_object_ids = 2;
inline bool ObjectOverlapCondition::has_target_object_ids() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectOverlapCondition::set_has_target_object_ids() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectOverlapCondition::clear_has_target_object_ids() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectOverlapCondition::clear_target_object_ids() {
  target_object_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_target_object_ids();
}
inline const ::std::string& ObjectOverlapCondition::target_object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.target_object_ids)
  return target_object_ids_.GetNoArena();
}
inline void ObjectOverlapCondition::set_target_object_ids(const ::std::string& value) {
  set_has_target_object_ids();
  target_object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
#if LANG_CXX11
inline void ObjectOverlapCondition::set_target_object_ids(::std::string&& value) {
  set_has_target_object_ids();
  target_object_ids_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
#endif
inline void ObjectOverlapCondition::set_target_object_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_object_ids();
  target_object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
inline void ObjectOverlapCondition::set_target_object_ids(const char* value, size_t size) {
  set_has_target_object_ids();
  target_object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
inline ::std::string* ObjectOverlapCondition::mutable_target_object_ids() {
  set_has_target_object_ids();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObjectOverlapCondition.target_object_ids)
  return target_object_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectOverlapCondition::release_target_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObjectOverlapCondition.target_object_ids)
  if (!has_target_object_ids()) {
    return NULL;
  }
  clear_has_target_object_ids();
  return target_object_ids_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectOverlapCondition::set_allocated_target_object_ids(::std::string* target_object_ids) {
  if (target_object_ids != NULL) {
    set_has_target_object_ids();
  } else {
    clear_has_target_object_ids();
  }
  target_object_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_object_ids);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}

// optional double distance = 3;
inline bool ObjectOverlapCondition::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectOverlapCondition::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectOverlapCondition::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectOverlapCondition::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double ObjectOverlapCondition::distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.distance)
  return distance_;
}
inline void ObjectOverlapCondition::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.distance)
}

// optional .apollo.simulation.ObjectOverlapCondition.DirectionType direction = 4 [default = EXCLUDE_BACK];
inline bool ObjectOverlapCondition::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectOverlapCondition::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectOverlapCondition::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectOverlapCondition::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::apollo::simulation::ObjectOverlapCondition_DirectionType ObjectOverlapCondition::direction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.direction)
  return static_cast< ::apollo::simulation::ObjectOverlapCondition_DirectionType >(direction_);
}
inline void ObjectOverlapCondition::set_direction(::apollo::simulation::ObjectOverlapCondition_DirectionType value) {
  assert(::apollo::simulation::ObjectOverlapCondition_DirectionType_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.direction)
}

// repeated string ignore_object_ids = 5;
inline int ObjectOverlapCondition::ignore_object_ids_size() const {
  return ignore_object_ids_.size();
}
inline void ObjectOverlapCondition::clear_ignore_object_ids() {
  ignore_object_ids_.Clear();
}
inline const ::std::string& ObjectOverlapCondition::ignore_object_ids(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return ignore_object_ids_.Get(index);
}
inline ::std::string* ObjectOverlapCondition::mutable_ignore_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return ignore_object_ids_.Mutable(index);
}
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  ignore_object_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  ignore_object_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ignore_object_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, const char* value, size_t size) {
  ignore_object_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline ::std::string* ObjectOverlapCondition::add_ignore_object_ids() {
  // @@protoc_insertion_point(field_add_mutable:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return ignore_object_ids_.Add();
}
inline void ObjectOverlapCondition::add_ignore_object_ids(const ::std::string& value) {
  ignore_object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
#if LANG_CXX11
inline void ObjectOverlapCondition::add_ignore_object_ids(::std::string&& value) {
  ignore_object_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
#endif
inline void ObjectOverlapCondition::add_ignore_object_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ignore_object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline void ObjectOverlapCondition::add_ignore_object_ids(const char* value, size_t size) {
  ignore_object_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ObjectOverlapCondition::ignore_object_ids() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return ignore_object_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ObjectOverlapCondition::mutable_ignore_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return &ignore_object_ids_;
}

// optional bool use_score = 6 [default = false];
inline bool ObjectOverlapCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectOverlapCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectOverlapCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectOverlapCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool ObjectOverlapCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.use_score)
  return use_score_;
}
inline void ObjectOverlapCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.use_score)
}

// -------------------------------------------------------------------

// RegionOverlapCondition

// optional string object_ids = 1;
inline bool RegionOverlapCondition::has_object_ids() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionOverlapCondition::set_has_object_ids() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionOverlapCondition::clear_has_object_ids() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionOverlapCondition::clear_object_ids() {
  object_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object_ids();
}
inline const ::std::string& RegionOverlapCondition::object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.object_ids)
  return object_ids_.GetNoArena();
}
inline void RegionOverlapCondition::set_object_ids(const ::std::string& value) {
  set_has_object_ids();
  object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.object_ids)
}
#if LANG_CXX11
inline void RegionOverlapCondition::set_object_ids(::std::string&& value) {
  set_has_object_ids();
  object_ids_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.RegionOverlapCondition.object_ids)
}
#endif
inline void RegionOverlapCondition::set_object_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_object_ids();
  object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.RegionOverlapCondition.object_ids)
}
inline void RegionOverlapCondition::set_object_ids(const char* value, size_t size) {
  set_has_object_ids();
  object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.RegionOverlapCondition.object_ids)
}
inline ::std::string* RegionOverlapCondition::mutable_object_ids() {
  set_has_object_ids();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.RegionOverlapCondition.object_ids)
  return object_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegionOverlapCondition::release_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.RegionOverlapCondition.object_ids)
  if (!has_object_ids()) {
    return NULL;
  }
  clear_has_object_ids();
  return object_ids_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegionOverlapCondition::set_allocated_object_ids(::std::string* object_ids) {
  if (object_ids != NULL) {
    set_has_object_ids();
  } else {
    clear_has_object_ids();
  }
  object_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_ids);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.RegionOverlapCondition.object_ids)
}

// repeated double region_corner_xy = 2 [packed = true];
inline int RegionOverlapCondition::region_corner_xy_size() const {
  return region_corner_xy_.size();
}
inline void RegionOverlapCondition::clear_region_corner_xy() {
  region_corner_xy_.Clear();
}
inline double RegionOverlapCondition::region_corner_xy(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.region_corner_xy)
  return region_corner_xy_.Get(index);
}
inline void RegionOverlapCondition::set_region_corner_xy(int index, double value) {
  region_corner_xy_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.region_corner_xy)
}
inline void RegionOverlapCondition::add_region_corner_xy(double value) {
  region_corner_xy_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.simulation.RegionOverlapCondition.region_corner_xy)
}
inline const ::google::protobuf::RepeatedField< double >&
RegionOverlapCondition::region_corner_xy() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.RegionOverlapCondition.region_corner_xy)
  return region_corner_xy_;
}
inline ::google::protobuf::RepeatedField< double >*
RegionOverlapCondition::mutable_region_corner_xy() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.RegionOverlapCondition.region_corner_xy)
  return &region_corner_xy_;
}

// optional bool require_fully_contain = 3;
inline bool RegionOverlapCondition::has_require_fully_contain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionOverlapCondition::set_has_require_fully_contain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegionOverlapCondition::clear_has_require_fully_contain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegionOverlapCondition::clear_require_fully_contain() {
  require_fully_contain_ = false;
  clear_has_require_fully_contain();
}
inline bool RegionOverlapCondition::require_fully_contain() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.require_fully_contain)
  return require_fully_contain_;
}
inline void RegionOverlapCondition::set_require_fully_contain(bool value) {
  set_has_require_fully_contain();
  require_fully_contain_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.require_fully_contain)
}

// optional double heading = 4;
inline bool RegionOverlapCondition::has_heading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionOverlapCondition::set_has_heading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionOverlapCondition::clear_has_heading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionOverlapCondition::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double RegionOverlapCondition::heading() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.heading)
  return heading_;
}
inline void RegionOverlapCondition::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.heading)
}

// optional bool use_score = 5 [default = false];
inline bool RegionOverlapCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionOverlapCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegionOverlapCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegionOverlapCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool RegionOverlapCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.use_score)
  return use_score_;
}
inline void RegionOverlapCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.use_score)
}

// -------------------------------------------------------------------

// RegionOverlapLWCondition

// optional string object_ids = 1;
inline bool RegionOverlapLWCondition::has_object_ids() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionOverlapLWCondition::set_has_object_ids() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionOverlapLWCondition::clear_has_object_ids() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionOverlapLWCondition::clear_object_ids() {
  object_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object_ids();
}
inline const ::std::string& RegionOverlapLWCondition::object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.object_ids)
  return object_ids_.GetNoArena();
}
inline void RegionOverlapLWCondition::set_object_ids(const ::std::string& value) {
  set_has_object_ids();
  object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
#if LANG_CXX11
inline void RegionOverlapLWCondition::set_object_ids(::std::string&& value) {
  set_has_object_ids();
  object_ids_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
#endif
inline void RegionOverlapLWCondition::set_object_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_object_ids();
  object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
inline void RegionOverlapLWCondition::set_object_ids(const char* value, size_t size) {
  set_has_object_ids();
  object_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
inline ::std::string* RegionOverlapLWCondition::mutable_object_ids() {
  set_has_object_ids();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.RegionOverlapLWCondition.object_ids)
  return object_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegionOverlapLWCondition::release_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.RegionOverlapLWCondition.object_ids)
  if (!has_object_ids()) {
    return NULL;
  }
  clear_has_object_ids();
  return object_ids_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegionOverlapLWCondition::set_allocated_object_ids(::std::string* object_ids) {
  if (object_ids != NULL) {
    set_has_object_ids();
  } else {
    clear_has_object_ids();
  }
  object_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_ids);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.RegionOverlapLWCondition.object_ids)
}

// optional double x = 2;
inline bool RegionOverlapLWCondition::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionOverlapLWCondition::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionOverlapLWCondition::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionOverlapLWCondition::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double RegionOverlapLWCondition::x() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.x)
  return x_;
}
inline void RegionOverlapLWCondition::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.x)
}

// optional double y = 3;
inline bool RegionOverlapLWCondition::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionOverlapLWCondition::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegionOverlapLWCondition::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegionOverlapLWCondition::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double RegionOverlapLWCondition::y() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.y)
  return y_;
}
inline void RegionOverlapLWCondition::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.y)
}

// optional double length = 4;
inline bool RegionOverlapLWCondition::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionOverlapLWCondition::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegionOverlapLWCondition::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegionOverlapLWCondition::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double RegionOverlapLWCondition::length() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.length)
  return length_;
}
inline void RegionOverlapLWCondition::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.length)
}

// optional double width = 5;
inline bool RegionOverlapLWCondition::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegionOverlapLWCondition::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegionOverlapLWCondition::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegionOverlapLWCondition::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double RegionOverlapLWCondition::width() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.width)
  return width_;
}
inline void RegionOverlapLWCondition::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.width)
}

// optional bool require_fully_contain = 6;
inline bool RegionOverlapLWCondition::has_require_fully_contain() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionOverlapLWCondition::set_has_require_fully_contain() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegionOverlapLWCondition::clear_has_require_fully_contain() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegionOverlapLWCondition::clear_require_fully_contain() {
  require_fully_contain_ = false;
  clear_has_require_fully_contain();
}
inline bool RegionOverlapLWCondition::require_fully_contain() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.require_fully_contain)
  return require_fully_contain_;
}
inline void RegionOverlapLWCondition::set_require_fully_contain(bool value) {
  set_has_require_fully_contain();
  require_fully_contain_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.require_fully_contain)
}

// optional bool use_score = 7 [default = false];
inline bool RegionOverlapLWCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegionOverlapLWCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegionOverlapLWCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegionOverlapLWCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool RegionOverlapLWCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.use_score)
  return use_score_;
}
inline void RegionOverlapLWCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.use_score)
}

// -------------------------------------------------------------------

// OnRoadCondition

// optional bool use_road_boundary = 1 [default = false];
inline bool OnRoadCondition::has_use_road_boundary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnRoadCondition::set_has_use_road_boundary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnRoadCondition::clear_has_use_road_boundary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnRoadCondition::clear_use_road_boundary() {
  use_road_boundary_ = false;
  clear_has_use_road_boundary();
}
inline bool OnRoadCondition::use_road_boundary() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.OnRoadCondition.use_road_boundary)
  return use_road_boundary_;
}
inline void OnRoadCondition::set_use_road_boundary(bool value) {
  set_has_use_road_boundary();
  use_road_boundary_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.OnRoadCondition.use_road_boundary)
}

// optional bool use_score = 2 [default = false];
inline bool OnRoadCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnRoadCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnRoadCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnRoadCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool OnRoadCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.OnRoadCondition.use_score)
  return use_score_;
}
inline void OnRoadCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.OnRoadCondition.use_score)
}

// -------------------------------------------------------------------

// RunRedLightCondition

// optional bool use_score = 1 [default = false];
inline bool RunRedLightCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunRedLightCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunRedLightCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunRedLightCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool RunRedLightCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RunRedLightCondition.use_score)
  return use_score_;
}
inline void RunRedLightCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RunRedLightCondition.use_score)
}

// -------------------------------------------------------------------

// RedLightStopCondition

// optional double min_distance = 1 [default = 2];
inline bool RedLightStopCondition::has_min_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedLightStopCondition::set_has_min_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedLightStopCondition::clear_has_min_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedLightStopCondition::clear_min_distance() {
  min_distance_ = 2;
  clear_has_min_distance();
}
inline double RedLightStopCondition::min_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.min_distance)
  return min_distance_;
}
inline void RedLightStopCondition::set_min_distance(double value) {
  set_has_min_distance();
  min_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.min_distance)
}

// optional double max_distance = 2 [default = 2.2];
inline bool RedLightStopCondition::has_max_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedLightStopCondition::set_has_max_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedLightStopCondition::clear_has_max_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedLightStopCondition::clear_max_distance() {
  max_distance_ = 2.2;
  clear_has_max_distance();
}
inline double RedLightStopCondition::max_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.max_distance)
  return max_distance_;
}
inline void RedLightStopCondition::set_max_distance(double value) {
  set_has_max_distance();
  max_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.max_distance)
}

// optional bool use_score = 3 [default = false];
inline bool RedLightStopCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedLightStopCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedLightStopCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedLightStopCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool RedLightStopCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.use_score)
  return use_score_;
}
inline void RedLightStopCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.use_score)
}

// optional double single_deduction = 4 [default = 5];
inline bool RedLightStopCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedLightStopCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedLightStopCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedLightStopCondition::clear_single_deduction() {
  single_deduction_ = 5;
  clear_has_single_deduction();
}
inline double RedLightStopCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.single_deduction)
  return single_deduction_;
}
inline void RedLightStopCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.single_deduction)
}

// -------------------------------------------------------------------

// ChangeLaneAtJunctionCondition

// -------------------------------------------------------------------

// RoutingCondition

// -------------------------------------------------------------------

// CrosswalkYieldCondition

// -------------------------------------------------------------------

// CrosswalkStopCondition

// optional double min_distance = 1 [default = 2.2];
inline bool CrosswalkStopCondition::has_min_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrosswalkStopCondition::set_has_min_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrosswalkStopCondition::clear_has_min_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CrosswalkStopCondition::clear_min_distance() {
  min_distance_ = 2.2;
  clear_has_min_distance();
}
inline double CrosswalkStopCondition::min_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.min_distance)
  return min_distance_;
}
inline void CrosswalkStopCondition::set_min_distance(double value) {
  set_has_min_distance();
  min_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.min_distance)
}

// optional double max_distance = 2 [default = 2.7];
inline bool CrosswalkStopCondition::has_max_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrosswalkStopCondition::set_has_max_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrosswalkStopCondition::clear_has_max_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrosswalkStopCondition::clear_max_distance() {
  max_distance_ = 2.7;
  clear_has_max_distance();
}
inline double CrosswalkStopCondition::max_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.max_distance)
  return max_distance_;
}
inline void CrosswalkStopCondition::set_max_distance(double value) {
  set_has_max_distance();
  max_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.max_distance)
}

// optional bool use_score = 3 [default = false];
inline bool CrosswalkStopCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkStopCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkStopCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkStopCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool CrosswalkStopCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.use_score)
  return use_score_;
}
inline void CrosswalkStopCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.use_score)
}

// optional double single_deduction = 4 [default = 5];
inline bool CrosswalkStopCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CrosswalkStopCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CrosswalkStopCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CrosswalkStopCondition::clear_single_deduction() {
  single_deduction_ = 5;
  clear_has_single_deduction();
}
inline double CrosswalkStopCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.single_deduction)
  return single_deduction_;
}
inline void CrosswalkStopCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.single_deduction)
}

// -------------------------------------------------------------------

// AbnormalStopCondition

// optional double duration = 1 [default = 5];
inline bool AbnormalStopCondition::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AbnormalStopCondition::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AbnormalStopCondition::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AbnormalStopCondition::clear_duration() {
  duration_ = 5;
  clear_has_duration();
}
inline double AbnormalStopCondition::duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.duration)
  return duration_;
}
inline void AbnormalStopCondition::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.duration)
}

// optional double distance = 2 [default = 10];
inline bool AbnormalStopCondition::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AbnormalStopCondition::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AbnormalStopCondition::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AbnormalStopCondition::clear_distance() {
  distance_ = 10;
  clear_has_distance();
}
inline double AbnormalStopCondition::distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.distance)
  return distance_;
}
inline void AbnormalStopCondition::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.distance)
}

// optional double x = 3;
inline bool AbnormalStopCondition::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbnormalStopCondition::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbnormalStopCondition::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbnormalStopCondition::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double AbnormalStopCondition::x() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.x)
  return x_;
}
inline void AbnormalStopCondition::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.x)
}

// optional double y = 4;
inline bool AbnormalStopCondition::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AbnormalStopCondition::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AbnormalStopCondition::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AbnormalStopCondition::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double AbnormalStopCondition::y() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.y)
  return y_;
}
inline void AbnormalStopCondition::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.y)
}

// -------------------------------------------------------------------

// BrakeTapCondition

// optional double min_duration = 1 [default = 1];
inline bool BrakeTapCondition::has_min_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrakeTapCondition::set_has_min_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrakeTapCondition::clear_has_min_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrakeTapCondition::clear_min_duration() {
  min_duration_ = 1;
  clear_has_min_duration();
}
inline double BrakeTapCondition::min_duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.BrakeTapCondition.min_duration)
  return min_duration_;
}
inline void BrakeTapCondition::set_min_duration(double value) {
  set_has_min_duration();
  min_duration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.BrakeTapCondition.min_duration)
}

// optional double max_duration = 2 [default = 4];
inline bool BrakeTapCondition::has_max_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrakeTapCondition::set_has_max_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrakeTapCondition::clear_has_max_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrakeTapCondition::clear_max_duration() {
  max_duration_ = 4;
  clear_has_max_duration();
}
inline double BrakeTapCondition::max_duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.BrakeTapCondition.max_duration)
  return max_duration_;
}
inline void BrakeTapCondition::set_max_duration(double value) {
  set_has_max_duration();
  max_duration_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.BrakeTapCondition.max_duration)
}

// -------------------------------------------------------------------

// RunStopSignCondition

// optional double distance = 1 [default = 2];
inline bool RunStopSignCondition::has_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunStopSignCondition::set_has_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunStopSignCondition::clear_has_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunStopSignCondition::clear_distance() {
  distance_ = 2;
  clear_has_distance();
}
inline double RunStopSignCondition::distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RunStopSignCondition.distance)
  return distance_;
}
inline void RunStopSignCondition::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.RunStopSignCondition.distance)
}

// -------------------------------------------------------------------

// CheckpointCondition

// repeated .apollo.simulation.Condition checkpoint = 1;
inline int CheckpointCondition::checkpoint_size() const {
  return checkpoint_.size();
}
inline void CheckpointCondition::clear_checkpoint() {
  checkpoint_.Clear();
}
inline ::apollo::simulation::Condition* CheckpointCondition::mutable_checkpoint(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.CheckpointCondition.checkpoint)
  return checkpoint_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >*
CheckpointCondition::mutable_checkpoint() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.CheckpointCondition.checkpoint)
  return &checkpoint_;
}
inline const ::apollo::simulation::Condition& CheckpointCondition::checkpoint(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CheckpointCondition.checkpoint)
  return checkpoint_.Get(index);
}
inline ::apollo::simulation::Condition* CheckpointCondition::add_checkpoint() {
  // @@protoc_insertion_point(field_add:apollo.simulation.CheckpointCondition.checkpoint)
  return checkpoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::simulation::Condition >&
CheckpointCondition::checkpoint() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.CheckpointCondition.checkpoint)
  return checkpoint_;
}

// -------------------------------------------------------------------

// DistToEndCondition

// -------------------------------------------------------------------

// DistToLaneCenterCondition

// -------------------------------------------------------------------

// TimeLimitCondition

// optional double timeout = 1;
inline bool TimeLimitCondition::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLimitCondition::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLimitCondition::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLimitCondition::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline double TimeLimitCondition::timeout() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.TimeLimitCondition.timeout)
  return timeout_;
}
inline void TimeLimitCondition::set_timeout(double value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.TimeLimitCondition.timeout)
}

// optional bool use_score = 2 [default = false];
inline bool TimeLimitCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLimitCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLimitCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLimitCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool TimeLimitCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.TimeLimitCondition.use_score)
  return use_score_;
}
inline void TimeLimitCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.TimeLimitCondition.use_score)
}

// -------------------------------------------------------------------

// SpeedbumpLimitCondition

// optional double speedbump_half_width = 1 [default = 0.2];
inline bool SpeedbumpLimitCondition::has_speedbump_half_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpeedbumpLimitCondition::set_has_speedbump_half_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpeedbumpLimitCondition::clear_has_speedbump_half_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpeedbumpLimitCondition::clear_speedbump_half_width() {
  speedbump_half_width_ = 0.2;
  clear_has_speedbump_half_width();
}
inline double SpeedbumpLimitCondition::speedbump_half_width() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.speedbump_half_width)
  return speedbump_half_width_;
}
inline void SpeedbumpLimitCondition::set_speedbump_half_width(double value) {
  set_has_speedbump_half_width();
  speedbump_half_width_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.speedbump_half_width)
}

// optional double max_speed = 2 [default = 3];
inline bool SpeedbumpLimitCondition::has_max_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpeedbumpLimitCondition::set_has_max_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpeedbumpLimitCondition::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpeedbumpLimitCondition::clear_max_speed() {
  max_speed_ = 3;
  clear_has_max_speed();
}
inline double SpeedbumpLimitCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.max_speed)
  return max_speed_;
}
inline void SpeedbumpLimitCondition::set_max_speed(double value) {
  set_has_max_speed();
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.max_speed)
}

// optional double deduction_speed_unit = 3 [default = 1];
inline bool SpeedbumpLimitCondition::has_deduction_speed_unit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpeedbumpLimitCondition::set_has_deduction_speed_unit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpeedbumpLimitCondition::clear_has_deduction_speed_unit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpeedbumpLimitCondition::clear_deduction_speed_unit() {
  deduction_speed_unit_ = 1;
  clear_has_deduction_speed_unit();
}
inline double SpeedbumpLimitCondition::deduction_speed_unit() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.deduction_speed_unit)
  return deduction_speed_unit_;
}
inline void SpeedbumpLimitCondition::set_deduction_speed_unit(double value) {
  set_has_deduction_speed_unit();
  deduction_speed_unit_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.deduction_speed_unit)
}

// optional bool use_score = 4 [default = false];
inline bool SpeedbumpLimitCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedbumpLimitCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedbumpLimitCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedbumpLimitCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool SpeedbumpLimitCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.use_score)
  return use_score_;
}
inline void SpeedbumpLimitCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.use_score)
}

// optional double single_deduction = 5 [default = 5];
inline bool SpeedbumpLimitCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpeedbumpLimitCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpeedbumpLimitCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpeedbumpLimitCondition::clear_single_deduction() {
  single_deduction_ = 5;
  clear_has_single_deduction();
}
inline double SpeedbumpLimitCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.single_deduction)
  return single_deduction_;
}
inline void SpeedbumpLimitCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.single_deduction)
}

// -------------------------------------------------------------------

// WorkingZoneAvoidLimitCondition

// repeated .apollo.hdmap.Polygon working_zone = 1;
inline int WorkingZoneAvoidLimitCondition::working_zone_size() const {
  return working_zone_.size();
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::mutable_working_zone(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return working_zone_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >*
WorkingZoneAvoidLimitCondition::mutable_working_zone() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return &working_zone_;
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::working_zone(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return working_zone_.Get(index);
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::add_working_zone() {
  // @@protoc_insertion_point(field_add:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return working_zone_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >&
WorkingZoneAvoidLimitCondition::working_zone() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return working_zone_;
}

// optional double max_speed = 2 [default = 8.33];
inline bool WorkingZoneAvoidLimitCondition::has_max_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkingZoneAvoidLimitCondition::set_has_max_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkingZoneAvoidLimitCondition::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkingZoneAvoidLimitCondition::clear_max_speed() {
  max_speed_ = 8.33;
  clear_has_max_speed();
}
inline double WorkingZoneAvoidLimitCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.max_speed)
  return max_speed_;
}
inline void WorkingZoneAvoidLimitCondition::set_max_speed(double value) {
  set_has_max_speed();
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.WorkingZoneAvoidLimitCondition.max_speed)
}

// optional .apollo.hdmap.Polygon whole_area = 3;
inline bool WorkingZoneAvoidLimitCondition::has_whole_area() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkingZoneAvoidLimitCondition::set_has_whole_area() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkingZoneAvoidLimitCondition::clear_has_whole_area() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::_internal_whole_area() const {
  return *whole_area_;
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::whole_area() const {
  const ::apollo::hdmap::Polygon* p = whole_area_;
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::hdmap::Polygon*>(
      &::apollo::hdmap::_Polygon_default_instance_);
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::release_whole_area() {
  // @@protoc_insertion_point(field_release:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
  clear_has_whole_area();
  ::apollo::hdmap::Polygon* temp = whole_area_;
  whole_area_ = NULL;
  return temp;
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::mutable_whole_area() {
  set_has_whole_area();
  if (whole_area_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArenaNoVirtual());
    whole_area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
  return whole_area_;
}
inline void WorkingZoneAvoidLimitCondition::set_allocated_whole_area(::apollo::hdmap::Polygon* whole_area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(whole_area_);
  }
  if (whole_area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      whole_area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, whole_area, submessage_arena);
    }
    set_has_whole_area();
  } else {
    clear_has_whole_area();
  }
  whole_area_ = whole_area;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
}

// optional bool use_score = 4 [default = false];
inline bool WorkingZoneAvoidLimitCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkingZoneAvoidLimitCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkingZoneAvoidLimitCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkingZoneAvoidLimitCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool WorkingZoneAvoidLimitCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.use_score)
  return use_score_;
}
inline void WorkingZoneAvoidLimitCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.WorkingZoneAvoidLimitCondition.use_score)
}

// optional double single_deduction = 5 [default = 3];
inline bool WorkingZoneAvoidLimitCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorkingZoneAvoidLimitCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorkingZoneAvoidLimitCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorkingZoneAvoidLimitCondition::clear_single_deduction() {
  single_deduction_ = 3;
  clear_has_single_deduction();
}
inline double WorkingZoneAvoidLimitCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.single_deduction)
  return single_deduction_;
}
inline void WorkingZoneAvoidLimitCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.WorkingZoneAvoidLimitCondition.single_deduction)
}

// -------------------------------------------------------------------

// LimitedTimeParkingCondition

// optional .apollo.hdmap.Polygon parking_lot = 1;
inline bool LimitedTimeParkingCondition::has_parking_lot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LimitedTimeParkingCondition::set_has_parking_lot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LimitedTimeParkingCondition::clear_has_parking_lot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::hdmap::Polygon& LimitedTimeParkingCondition::_internal_parking_lot() const {
  return *parking_lot_;
}
inline const ::apollo::hdmap::Polygon& LimitedTimeParkingCondition::parking_lot() const {
  const ::apollo::hdmap::Polygon* p = parking_lot_;
  // @@protoc_insertion_point(field_get:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::hdmap::Polygon*>(
      &::apollo::hdmap::_Polygon_default_instance_);
}
inline ::apollo::hdmap::Polygon* LimitedTimeParkingCondition::release_parking_lot() {
  // @@protoc_insertion_point(field_release:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
  clear_has_parking_lot();
  ::apollo::hdmap::Polygon* temp = parking_lot_;
  parking_lot_ = NULL;
  return temp;
}
inline ::apollo::hdmap::Polygon* LimitedTimeParkingCondition::mutable_parking_lot() {
  set_has_parking_lot();
  if (parking_lot_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArenaNoVirtual());
    parking_lot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
  return parking_lot_;
}
inline void LimitedTimeParkingCondition::set_allocated_parking_lot(::apollo::hdmap::Polygon* parking_lot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parking_lot_);
  }
  if (parking_lot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking_lot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking_lot, submessage_arena);
    }
    set_has_parking_lot();
  } else {
    clear_has_parking_lot();
  }
  parking_lot_ = parking_lot;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
}

// optional bool use_score = 2 [default = false];
inline bool LimitedTimeParkingCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LimitedTimeParkingCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LimitedTimeParkingCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LimitedTimeParkingCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool LimitedTimeParkingCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LimitedTimeParkingCondition.use_score)
  return use_score_;
}
inline void LimitedTimeParkingCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.LimitedTimeParkingCondition.use_score)
}

// optional double single_deduction = 3 [default = 5];
inline bool LimitedTimeParkingCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LimitedTimeParkingCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LimitedTimeParkingCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LimitedTimeParkingCondition::clear_single_deduction() {
  single_deduction_ = 5;
  clear_has_single_deduction();
}
inline double LimitedTimeParkingCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LimitedTimeParkingCondition.single_deduction)
  return single_deduction_;
}
inline void LimitedTimeParkingCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.LimitedTimeParkingCondition.single_deduction)
}

// -------------------------------------------------------------------

// FollowAndBypassCondition

// optional .apollo.hdmap.Polygon test_range = 1;
inline bool FollowAndBypassCondition::has_test_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FollowAndBypassCondition::set_has_test_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FollowAndBypassCondition::clear_has_test_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::hdmap::Polygon& FollowAndBypassCondition::_internal_test_range() const {
  return *test_range_;
}
inline const ::apollo::hdmap::Polygon& FollowAndBypassCondition::test_range() const {
  const ::apollo::hdmap::Polygon* p = test_range_;
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.test_range)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::hdmap::Polygon*>(
      &::apollo::hdmap::_Polygon_default_instance_);
}
inline ::apollo::hdmap::Polygon* FollowAndBypassCondition::release_test_range() {
  // @@protoc_insertion_point(field_release:apollo.simulation.FollowAndBypassCondition.test_range)
  clear_has_test_range();
  ::apollo::hdmap::Polygon* temp = test_range_;
  test_range_ = NULL;
  return temp;
}
inline ::apollo::hdmap::Polygon* FollowAndBypassCondition::mutable_test_range() {
  set_has_test_range();
  if (test_range_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArenaNoVirtual());
    test_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.FollowAndBypassCondition.test_range)
  return test_range_;
}
inline void FollowAndBypassCondition::set_allocated_test_range(::apollo::hdmap::Polygon* test_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(test_range_);
  }
  if (test_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      test_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, test_range, submessage_arena);
    }
    set_has_test_range();
  } else {
    clear_has_test_range();
  }
  test_range_ = test_range;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.FollowAndBypassCondition.test_range)
}

// optional double divide_speed = 2 [default = 3];
inline bool FollowAndBypassCondition::has_divide_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FollowAndBypassCondition::set_has_divide_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FollowAndBypassCondition::clear_has_divide_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FollowAndBypassCondition::clear_divide_speed() {
  divide_speed_ = 3;
  clear_has_divide_speed();
}
inline double FollowAndBypassCondition::divide_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.divide_speed)
  return divide_speed_;
}
inline void FollowAndBypassCondition::set_divide_speed(double value) {
  set_has_divide_speed();
  divide_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.FollowAndBypassCondition.divide_speed)
}

// optional string obstacle_id = 3;
inline bool FollowAndBypassCondition::has_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FollowAndBypassCondition::set_has_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FollowAndBypassCondition::clear_has_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FollowAndBypassCondition::clear_obstacle_id() {
  obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_obstacle_id();
}
inline const ::std::string& FollowAndBypassCondition::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.obstacle_id)
  return obstacle_id_.GetNoArena();
}
inline void FollowAndBypassCondition::set_obstacle_id(const ::std::string& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
#if LANG_CXX11
inline void FollowAndBypassCondition::set_obstacle_id(::std::string&& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
#endif
inline void FollowAndBypassCondition::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
inline void FollowAndBypassCondition::set_obstacle_id(const char* value, size_t size) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
inline ::std::string* FollowAndBypassCondition::mutable_obstacle_id() {
  set_has_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.FollowAndBypassCondition.obstacle_id)
  return obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowAndBypassCondition::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.simulation.FollowAndBypassCondition.obstacle_id)
  if (!has_obstacle_id()) {
    return NULL;
  }
  clear_has_obstacle_id();
  return obstacle_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowAndBypassCondition::set_allocated_obstacle_id(::std::string* obstacle_id) {
  if (obstacle_id != NULL) {
    set_has_obstacle_id();
  } else {
    clear_has_obstacle_id();
  }
  obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}

// optional .apollo.hdmap.LineSegment end_line = 4;
inline bool FollowAndBypassCondition::has_end_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FollowAndBypassCondition::set_has_end_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FollowAndBypassCondition::clear_has_end_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::hdmap::LineSegment& FollowAndBypassCondition::_internal_end_line() const {
  return *end_line_;
}
inline const ::apollo::hdmap::LineSegment& FollowAndBypassCondition::end_line() const {
  const ::apollo::hdmap::LineSegment* p = end_line_;
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.end_line)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::hdmap::LineSegment*>(
      &::apollo::hdmap::_LineSegment_default_instance_);
}
inline ::apollo::hdmap::LineSegment* FollowAndBypassCondition::release_end_line() {
  // @@protoc_insertion_point(field_release:apollo.simulation.FollowAndBypassCondition.end_line)
  clear_has_end_line();
  ::apollo::hdmap::LineSegment* temp = end_line_;
  end_line_ = NULL;
  return temp;
}
inline ::apollo::hdmap::LineSegment* FollowAndBypassCondition::mutable_end_line() {
  set_has_end_line();
  if (end_line_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::LineSegment>(GetArenaNoVirtual());
    end_line_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.FollowAndBypassCondition.end_line)
  return end_line_;
}
inline void FollowAndBypassCondition::set_allocated_end_line(::apollo::hdmap::LineSegment* end_line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_line_);
  }
  if (end_line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end_line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_line, submessage_arena);
    }
    set_has_end_line();
  } else {
    clear_has_end_line();
  }
  end_line_ = end_line;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.FollowAndBypassCondition.end_line)
}

// optional bool use_score = 5 [default = false];
inline bool FollowAndBypassCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FollowAndBypassCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FollowAndBypassCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FollowAndBypassCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool FollowAndBypassCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.use_score)
  return use_score_;
}
inline void FollowAndBypassCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.FollowAndBypassCondition.use_score)
}

// -------------------------------------------------------------------

// ObstacleBypassCondition

// optional .apollo.hdmap.Polygon test_range = 1;
inline bool ObstacleBypassCondition::has_test_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObstacleBypassCondition::set_has_test_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObstacleBypassCondition::clear_has_test_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::hdmap::Polygon& ObstacleBypassCondition::_internal_test_range() const {
  return *test_range_;
}
inline const ::apollo::hdmap::Polygon& ObstacleBypassCondition::test_range() const {
  const ::apollo::hdmap::Polygon* p = test_range_;
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.test_range)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::hdmap::Polygon*>(
      &::apollo::hdmap::_Polygon_default_instance_);
}
inline ::apollo::hdmap::Polygon* ObstacleBypassCondition::release_test_range() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObstacleBypassCondition.test_range)
  clear_has_test_range();
  ::apollo::hdmap::Polygon* temp = test_range_;
  test_range_ = NULL;
  return temp;
}
inline ::apollo::hdmap::Polygon* ObstacleBypassCondition::mutable_test_range() {
  set_has_test_range();
  if (test_range_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArenaNoVirtual());
    test_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObstacleBypassCondition.test_range)
  return test_range_;
}
inline void ObstacleBypassCondition::set_allocated_test_range(::apollo::hdmap::Polygon* test_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(test_range_);
  }
  if (test_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      test_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, test_range, submessage_arena);
    }
    set_has_test_range();
  } else {
    clear_has_test_range();
  }
  test_range_ = test_range;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObstacleBypassCondition.test_range)
}

// optional string obstacle_id = 2;
inline bool ObstacleBypassCondition::has_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleBypassCondition::set_has_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleBypassCondition::clear_has_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleBypassCondition::clear_obstacle_id() {
  obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_obstacle_id();
}
inline const ::std::string& ObstacleBypassCondition::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.obstacle_id)
  return obstacle_id_.GetNoArena();
}
inline void ObstacleBypassCondition::set_obstacle_id(const ::std::string& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
#if LANG_CXX11
inline void ObstacleBypassCondition::set_obstacle_id(::std::string&& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
#endif
inline void ObstacleBypassCondition::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
inline void ObstacleBypassCondition::set_obstacle_id(const char* value, size_t size) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
inline ::std::string* ObstacleBypassCondition::mutable_obstacle_id() {
  set_has_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObstacleBypassCondition.obstacle_id)
  return obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObstacleBypassCondition::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObstacleBypassCondition.obstacle_id)
  if (!has_obstacle_id()) {
    return NULL;
  }
  clear_has_obstacle_id();
  return obstacle_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObstacleBypassCondition::set_allocated_obstacle_id(::std::string* obstacle_id) {
  if (obstacle_id != NULL) {
    set_has_obstacle_id();
  } else {
    clear_has_obstacle_id();
  }
  obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}

// optional double min_lateral_distance = 3 [default = 1];
inline bool ObstacleBypassCondition::has_min_lateral_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObstacleBypassCondition::set_has_min_lateral_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObstacleBypassCondition::clear_has_min_lateral_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObstacleBypassCondition::clear_min_lateral_distance() {
  min_lateral_distance_ = 1;
  clear_has_min_lateral_distance();
}
inline double ObstacleBypassCondition::min_lateral_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.min_lateral_distance)
  return min_lateral_distance_;
}
inline void ObstacleBypassCondition::set_min_lateral_distance(double value) {
  set_has_min_lateral_distance();
  min_lateral_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.min_lateral_distance)
}

// optional double max_speed = 4 [default = 5];
inline bool ObstacleBypassCondition::has_max_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObstacleBypassCondition::set_has_max_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObstacleBypassCondition::clear_has_max_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObstacleBypassCondition::clear_max_speed() {
  max_speed_ = 5;
  clear_has_max_speed();
}
inline double ObstacleBypassCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.max_speed)
  return max_speed_;
}
inline void ObstacleBypassCondition::set_max_speed(double value) {
  set_has_max_speed();
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.max_speed)
}

// optional bool use_score = 5 [default = false];
inline bool ObstacleBypassCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleBypassCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleBypassCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleBypassCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool ObstacleBypassCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.use_score)
  return use_score_;
}
inline void ObstacleBypassCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.use_score)
}

// optional double single_deduction = 6 [default = 5];
inline bool ObstacleBypassCondition::has_single_deduction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObstacleBypassCondition::set_has_single_deduction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObstacleBypassCondition::clear_has_single_deduction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObstacleBypassCondition::clear_single_deduction() {
  single_deduction_ = 5;
  clear_has_single_deduction();
}
inline double ObstacleBypassCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.single_deduction)
  return single_deduction_;
}
inline void ObstacleBypassCondition::set_single_deduction(double value) {
  set_has_single_deduction();
  single_deduction_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.single_deduction)
}

// -------------------------------------------------------------------

// AntiCheatingCondition

// optional bool use_score = 1 [default = false];
inline bool AntiCheatingCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AntiCheatingCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AntiCheatingCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AntiCheatingCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool AntiCheatingCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AntiCheatingCondition.use_score)
  return use_score_;
}
inline void AntiCheatingCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.AntiCheatingCondition.use_score)
}

// -------------------------------------------------------------------

// KeyPoint

// optional double x = 1;
inline bool KeyPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double KeyPoint::x() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.x)
  return x_;
}
inline void KeyPoint::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.x)
}

// optional double y = 2;
inline bool KeyPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double KeyPoint::y() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.y)
  return y_;
}
inline void KeyPoint::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.y)
}

// optional double z = 3 [default = 0];
inline bool KeyPoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyPoint::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyPoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyPoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double KeyPoint::z() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.z)
  return z_;
}
inline void KeyPoint::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.z)
}

// optional double radius = 4 [default = 2];
inline bool KeyPoint::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyPoint::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyPoint::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyPoint::clear_radius() {
  radius_ = 2;
  clear_has_radius();
}
inline double KeyPoint::radius() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.radius)
  return radius_;
}
inline void KeyPoint::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.radius)
}

// -------------------------------------------------------------------

// KeyPointCondition

// optional bool use_score = 1 [default = false];
inline bool KeyPointCondition::has_use_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyPointCondition::set_has_use_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyPointCondition::clear_has_use_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyPointCondition::clear_use_score() {
  use_score_ = false;
  clear_has_use_score();
}
inline bool KeyPointCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.use_score)
  return use_score_;
}
inline void KeyPointCondition::set_use_score(bool value) {
  set_has_use_score();
  use_score_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPointCondition.use_score)
}

// optional bool in_order = 2 [default = true];
inline bool KeyPointCondition::has_in_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyPointCondition::set_has_in_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyPointCondition::clear_has_in_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyPointCondition::clear_in_order() {
  in_order_ = true;
  clear_has_in_order();
}
inline bool KeyPointCondition::in_order() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.in_order)
  return in_order_;
}
inline void KeyPointCondition::set_in_order(bool value) {
  set_has_in_order();
  in_order_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPointCondition.in_order)
}

// optional double radius = 3 [default = 2];
inline bool KeyPointCondition::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyPointCondition::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyPointCondition::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyPointCondition::clear_radius() {
  radius_ = 2;
  clear_has_radius();
}
inline double KeyPointCondition::radius() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.radius)
  return radius_;
}
inline void KeyPointCondition::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPointCondition.radius)
}

// repeated .apollo.simulation.KeyPoint point = 4;
inline int KeyPointCondition::point_size() const {
  return point_.size();
}
inline void KeyPointCondition::clear_point() {
  point_.Clear();
}
inline ::apollo::simulation::KeyPoint* KeyPointCondition::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.KeyPointCondition.point)
  return point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::simulation::KeyPoint >*
KeyPointCondition::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.KeyPointCondition.point)
  return &point_;
}
inline const ::apollo::simulation::KeyPoint& KeyPointCondition::point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.point)
  return point_.Get(index);
}
inline ::apollo::simulation::KeyPoint* KeyPointCondition::add_point() {
  // @@protoc_insertion_point(field_add:apollo.simulation.KeyPointCondition.point)
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::simulation::KeyPoint >&
KeyPointCondition::point() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.KeyPointCondition.point)
  return point_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace simulation
}  // namespace apollo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::simulation::LogicalCondition_OperatorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::simulation::LogicalCondition_OperatorType>() {
  return ::apollo::simulation::LogicalCondition_OperatorType_descriptor();
}
template <> struct is_proto_enum< ::apollo::simulation::ObjectOverlapCondition_DirectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::simulation::ObjectOverlapCondition_DirectionType>() {
  return ::apollo::simulation::ObjectOverlapCondition_DirectionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto
